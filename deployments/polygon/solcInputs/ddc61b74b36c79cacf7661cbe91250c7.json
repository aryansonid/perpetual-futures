{
  "language": "Solidity",
  "sources": {
    "contracts/contracts6_2/GNSReferralsV6_2.sol": {
      "content": "/**\n *Submitted for verification at PolygonScan.com on 2022-08-16\n*/\n\n// File: contracts\\interfaces\\UniswapRouterInterfaceV5.sol\n// SPDX-License-Identifier: MIT\n\n/// DEPLOY need storage \n\npragma solidity 0.8.15;\n\ninterface UniswapRouterInterfaceV5{\n\tfunction swapExactTokensForTokens(\n\t\tuint amountIn,\n\t\tuint amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external returns (uint[] memory amounts);\n\n\tfunction swapTokensForExactTokens(\n\t\tuint amountOut,\n\t\tuint amountInMax,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external returns (uint[] memory amounts);\n}\n\n// File: contracts\\interfaces\\TokenInterfaceV5.sol\n\npragma solidity 0.8.15;\n\ninterface TokenInterfaceV5{\n    function burn(address, uint256) external;\n    function mint(address, uint256) external;\n    function transfer(address, uint256) external returns (bool);\n    function transferFrom(address, address, uint256) external returns(bool);\n    function balanceOf(address) external view returns(uint256);\n    function hasRole(bytes32, address) external view returns (bool);\n    function approve(address, uint256) external returns (bool);\n    function allowance(address, address) external view returns (uint256);\n}\n\n// File: contracts\\interfaces\\NftInterfaceV5.sol\n\npragma solidity 0.8.15;\n\ninterface NftInterfaceV5{\n    function balanceOf(address) external view returns (uint);\n    function ownerOf(uint) external view returns (address);\n    function transferFrom(address, address, uint) external;\n    function tokenOfOwnerByIndex(address, uint) external view returns(uint);\n}\n\n// File: contracts\\interfaces\\VaultInterfaceV5.sol\n\npragma solidity 0.8.15;\n\ninterface VaultInterfaceV5{\n\tfunction sendWETHToTrader(address, uint) external;\n\tfunction receiveWETHFromTrader(address, uint, uint) external;\n\tfunction currentBalanceWETH() external view returns(uint);\n\tfunction distributeRewardWETH(uint) external;\n}\n\n// File: contracts\\interfaces\\PairsStorageInterfaceV6.sol\n\npragma solidity 0.8.15;\n\ninterface PairsStorageInterfaceV6{\n    enum FeedCalculation { DEFAULT, INVERT, COMBINE }    // FEED 1, 1 / (FEED 1), (FEED 1)/(FEED 2)\n    struct Feed{ address feed1; address feed2; FeedCalculation feedCalculation; uint maxDeviationP; } // PRECISION (%)\n    function incrementCurrentOrderId() external returns(uint);\n    function updateGroupCollateral(uint, uint, bool, bool) external;\n    function pairJob(uint) external returns(string memory, string memory, bytes32, uint);\n    function pairFeed(uint) external view returns(Feed memory);\n    function pairSpreadP(uint) external view returns(uint);\n    function pairMinLeverage(uint) external view returns(uint);\n    function pairMaxLeverage(uint) external view returns(uint);\n    function groupMaxCollateral(uint) external view returns(uint);\n    function groupCollateral(uint, bool) external view returns(uint);\n    function guaranteedSlEnabled(uint) external view returns(bool);\n    function pairOpenFeeP(uint) external view returns(uint);\n    function pairCloseFeeP(uint) external view returns(uint);\n    function pairOracleFeeP(uint) external view returns(uint);\n    function pairNftLimitOrderFeeP(uint) external view returns(uint);\n    function pairReferralFeeP(uint) external view returns(uint);\n    function pairMinLevPosWETH(uint) external view returns(uint);\n}\n\n// File: contracts\\interfaces\\StorageInterfaceV5.sol\n\npragma solidity 0.8.15;\n\ninterface StorageInterfaceV5{\n    enum LimitOrder { TP, SL, LIQ, OPEN }\n    struct Trader{\n        uint leverageUnlocked;\n        address referral;\n        uint referralRewardsTotal;  // 1e18\n    }\n    struct Trade{\n        address trader;\n        uint pairIndex;\n        uint index;\n        uint initialPosToken;       // 1e18\n        uint positionSizeWETH;       // 1e18\n        uint openPrice;             // PRECISION\n        bool buy;\n        uint leverage;\n        uint tp;                    // PRECISION\n        uint sl;                    // PRECISION\n    }\n    struct TradeInfo{\n        uint tokenId;\n        uint tokenPriceWETH;         // PRECISION\n        uint openInterestWETH;       // 1e18\n        uint tpLastUpdated;\n        uint slLastUpdated;\n        bool beingMarketClosed;\n    }\n    struct OpenLimitOrder{\n        address trader;\n        uint pairIndex;\n        uint index;\n        uint positionSize;          // 1e18 (WETH or GFARM2)\n        uint spreadReductionP;\n        bool buy;\n        uint leverage;\n        uint tp;                    // PRECISION (%)\n        uint sl;                    // PRECISION (%)\n        uint minPrice;              // PRECISION\n        uint maxPrice;              // PRECISION\n        uint block;\n        uint tokenId;               // index in supportedTokens\n    }\n    struct PendingMarketOrder{\n        Trade trade;\n        uint block;\n        uint wantedPrice;           // PRECISION\n        uint slippageP;             // PRECISION (%)\n        uint spreadReductionP;\n        uint tokenId;               // index in supportedTokens\n    }\n    struct PendingNftOrder{\n        address nftHolder;\n        uint nftId;\n        address trader;\n        uint pairIndex;\n        uint index;\n        LimitOrder orderType;\n    }\n    function PRECISION() external pure returns(uint);\n    function gov() external view returns(address);\n    function dev() external view returns(address);\n    function WETH() external view returns(TokenInterfaceV5);\n    function token() external view returns(TokenInterfaceV5);\n    function linkErc677() external view returns(TokenInterfaceV5);\n    function tokenWETHRouter() external view returns(UniswapRouterInterfaceV5);\n    function priceAggregator() external view returns(AggregatorInterfaceV6_2);\n    function vault() external view returns(VaultInterfaceV5);\n    function trading() external view returns(address);\n    function callbacks() external view returns(address);\n    function handleTokens(address,uint,bool) external;\n    function transferWETH(address, address, uint) external;\n    function transferLinkToAggregator(address, uint, uint) external;\n    function unregisterTrade(address, uint, uint) external;\n    function unregisterPendingMarketOrder(uint, bool) external;\n    function unregisterOpenLimitOrder(address, uint, uint) external;\n    function hasOpenLimitOrder(address, uint, uint) external view returns(bool);\n    function storePendingMarketOrder(PendingMarketOrder memory, uint, bool) external;\n    function storeReferral(address, address) external;\n    function openTrades(address, uint, uint) external view returns(Trade memory);\n    function openTradesInfo(address, uint, uint) external view returns(TradeInfo memory);\n    function updateSl(address, uint, uint, uint) external;\n    function updateTp(address, uint, uint, uint) external;\n    function getOpenLimitOrder(address, uint, uint) external view returns(OpenLimitOrder memory);\n    function spreadReductionsP(uint) external view returns(uint);\n    function positionSizeTokenDynamic(uint,uint) external view returns(uint);\n    function maxSlP() external view returns(uint);\n    function storeOpenLimitOrder(OpenLimitOrder memory) external;\n    function reqID_pendingMarketOrder(uint) external view returns(PendingMarketOrder memory);\n    function storePendingNftOrder(PendingNftOrder memory, uint) external;\n    function updateOpenLimitOrder(OpenLimitOrder calldata) external;\n    function firstEmptyTradeIndex(address, uint) external view returns(uint);\n    function firstEmptyOpenLimitIndex(address, uint) external view returns(uint);\n    function increaseNftRewards(uint, uint) external;\n    function nftSuccessTimelock() external view returns(uint);\n    function currentPercentProfit(uint,uint,bool,uint) external view returns(int);\n    function reqID_pendingNftOrder(uint) external view returns(PendingNftOrder memory);\n    function setNftLastSuccess(uint) external;\n    function updateTrade(Trade memory) external;\n    function nftLastSuccess(uint) external view returns(uint);\n    function unregisterPendingNftOrder(uint) external;\n    function handleDevGovFees(uint, uint, bool, bool) external returns(uint);\n    function distributeLpRewards(uint) external;\n    function getReferral(address) external view returns(address);\n    function increaseReferralRewards(address, uint) external;\n    function storeTrade(Trade memory, TradeInfo memory) external;\n    function setLeverageUnlocked(address, uint) external;\n    function getLeverageUnlocked(address) external view returns(uint);\n    function openLimitOrdersCount(address, uint) external view returns(uint);\n    function maxOpenLimitOrdersPerPair() external view returns(uint);\n    function openTradesCount(address, uint) external view returns(uint);\n    function pendingMarketOpenCount(address, uint) external view returns(uint);\n    function pendingMarketCloseCount(address, uint) external view returns(uint);\n    function maxTradesPerPair() external view returns(uint);\n    function maxTradesPerBlock() external view returns(uint);\n    function tradesPerBlock(uint) external view returns(uint);\n    function pendingOrderIdsCount(address) external view returns(uint);\n    function maxPendingMarketOrders() external view returns(uint);\n    function maxGainP() external view returns(uint);\n    function defaultLeverageUnlocked() external view returns(uint);\n    function openInterestWETH(uint, uint) external view returns(uint);\n    function getPendingOrderIds(address) external view returns(uint[] memory);\n    function traders(address) external view returns(Trader memory);\n    function nfts(uint) external view returns(NftInterfaceV5);\n}\n\ninterface AggregatorInterfaceV6_2{\n    enum OrderType { MARKET_OPEN, MARKET_CLOSE, LIMIT_OPEN, LIMIT_CLOSE, UPDATE_SL }\n    function pairsStorage() external view returns(PairsStorageInterfaceV6);\n    function getPrice(uint,OrderType,uint) external returns(uint);\n    function tokenPriceWETH() external returns(uint);\n    function linkFee(uint,uint) external view returns(uint);\n    function tokenWETHReservesLp() external view returns(uint, uint);\n    function pendingSlOrders(uint) external view returns(PendingSl memory);\n    function storePendingSlOrder(uint orderId, PendingSl calldata p) external;\n    function unregisterPendingSlOrder(uint orderId) external;\n    struct PendingSl{address trader; uint pairIndex; uint index; uint openPrice; bool buy; uint newSl; }\n}\n\ninterface NftRewardsInterfaceV6{\n    struct TriggeredLimitId{ address trader; uint pairIndex; uint index; StorageInterfaceV5.LimitOrder order; }\n    enum OpenLimitOrderType{ LEGACY, REVERSAL, MOMENTUM }\n    function storeFirstToTrigger(TriggeredLimitId calldata, address) external;\n    function storeTriggerSameBlock(TriggeredLimitId calldata, address) external;\n    function unregisterTrigger(TriggeredLimitId calldata) external;\n    function distributeNftReward(TriggeredLimitId calldata, uint) external;\n    function openLimitOrderTypes(address, uint, uint) external view returns(OpenLimitOrderType);\n    function setOpenLimitOrderType(address, uint, uint, OpenLimitOrderType) external;\n    function triggered(TriggeredLimitId calldata) external view returns(bool);\n    function timedOut(TriggeredLimitId calldata) external view returns(bool);\n}\n\n// File: contracts\\GNSReferralsV6_2.sol\n\npragma solidity 0.8.15;\n\ncontract GNSReferralsV6_2 {\n\n    // CONSTANTS\n    uint constant PRECISION = 1e10;\n    StorageInterfaceV5 public immutable storageT;\n\n    // ADJUSTABLE PARAMETERS\n    uint public allyFeeP;           // % (of referrer fees going to allies, eg. 10)\n    uint public startReferrerFeeP;  // % (of referrer fee when 0 volume referred, eg. 75)\n    uint public openFeeP;           // % (of opening fee used for referral system, eg. 33)\n    uint public targetVolumeWETH;    // WETH (to reach maximum referral system fee, eg. 1e8)\n\n    // CUSTOM TYPES\n    struct AllyDetails{\n        address[] referrersReferred;\n        uint volumeReferredWETH;    // 1e18\n        uint pendingRewardsToken;  // 1e18\n        uint totalRewardsToken;    // 1e18\n        uint totalRewardsValueWETH; // 1e18\n        bool active;\n    }\n\n    struct ReferrerDetails{\n        address ally;\n        address[] tradersReferred;\n        uint volumeReferredWETH;    // 1e18\n        uint pendingRewardsToken;  // 1e18\n        uint totalRewardsToken;    // 1e18\n        uint totalRewardsValueWETH; // 1e18\n        bool active;\n    }\n\n    // STATE (MAPPINGS)\n    mapping(address => AllyDetails) public allyDetails;\n    mapping(address => ReferrerDetails) public referrerDetails;\n\n    mapping(address => address) public referrerByTrader;\n\n    // EVENTS\n    event UpdatedAllyFeeP(uint value);\n    event UpdatedStartReferrerFeeP(uint value);\n    event UpdatedOpenFeeP(uint value);\n    event UpdatedTargetVolumeWETH(uint value);\n\n    event AllyWhitelisted(address indexed ally);\n    event AllyUnwhitelisted(address indexed ally);\n\n    event ReferrerWhitelisted(\n        address indexed referrer,\n        address indexed ally\n    );\n    event ReferrerUnwhitelisted(address indexed referrer);\n    event ReferrerRegistered(\n        address indexed trader,\n        address indexed referrer\n    );\n\n    event AllyRewardDistributed(\n        address indexed ally,\n        address indexed trader,\n        uint volumeWETH,\n        uint amountToken,\n        uint amountValueWETH\n    );\n    event ReferrerRewardDistributed(\n        address indexed referrer,\n        address indexed trader,\n        uint volumeWETH,\n        uint amountToken,\n        uint amountValueWETH\n    );\n\n    event AllyRewardsClaimed(\n        address indexed ally,\n        uint amountToken\n    );\n    event ReferrerRewardsClaimed(\n        address indexed referrer,\n        uint amountToken\n    );\n\n    constructor(\n        StorageInterfaceV5 _storageT,\n        uint _allyFeeP,\n        uint _startReferrerFeeP,\n        uint _openFeeP,\n        uint _targetVolumeWETH\n    ){\n        require(address(_storageT) != address(0)\n            && _allyFeeP <= 50\n            && _startReferrerFeeP <= 100\n            && _openFeeP <= 50\n            && _targetVolumeWETH > 0, \"WRONG_PARAMS\");\n\n        storageT = _storageT;\n\n        allyFeeP = _allyFeeP;\n        startReferrerFeeP = _startReferrerFeeP;\n        openFeeP = _openFeeP;\n        targetVolumeWETH = _targetVolumeWETH;\n    }\n\n    // MODIFIERS\n    modifier onlyGov(){\n        require(msg.sender == storageT.gov(), \"GOV_ONLY\");\n        _;\n    }\n    modifier onlyTrading(){\n        require(msg.sender == storageT.trading(), \"TRADING_ONLY\");\n        _;\n    }\n    modifier onlyCallbacks(){\n        require(msg.sender == storageT.callbacks(), \"CALLBACKS_ONLY\");\n        _;\n    }\n\n    // MANAGE PARAMETERS\n    function updateAllyFeeP(uint value) external onlyGov{\n        require(value <= 50, \"VALUE_ABOVE_50\");\n\n        allyFeeP = value;\n        \n        emit UpdatedAllyFeeP(value);\n    }\n    function updateStartReferrerFeeP(uint value) external onlyGov{\n        require(value <= 100, \"VALUE_ABOVE_100\");\n\n        startReferrerFeeP = value;\n\n        emit UpdatedStartReferrerFeeP(value);\n    }\n    function updateOpenFeeP(uint value) external onlyGov{\n        require(value <= 50, \"VALUE_ABOVE_50\");\n\n        openFeeP = value;\n\n        emit UpdatedOpenFeeP(value);\n    }\n    function updateTargetVolumeWETH(uint value) external onlyGov{\n        require(value > 0, \"VALUE_0\");\n\n        targetVolumeWETH = value;\n        \n        emit UpdatedTargetVolumeWETH(value);\n    }\n\n    // MANAGE ALLIES\n    function whitelistAlly(address ally) external onlyGov{\n        require(ally != address(0), \"ADDRESS_0\");\n\n        AllyDetails storage a = allyDetails[ally];\n        require(!a.active, \"ALLY_ALREADY_ACTIVE\");\n\n        a.active = true;\n\n        emit AllyWhitelisted(ally);\n    }\n    function unwhitelistAlly(address ally) external onlyGov{\n        AllyDetails storage a = allyDetails[ally];\n        require(a.active, \"ALREADY_UNACTIVE\");\n\n        a.active = false;\n\n        emit AllyUnwhitelisted(ally);\n    }\n\n    // MANAGE REFERRERS\n    function whitelistReferrer(\n        address referrer,\n        address ally\n    ) external onlyGov{\n        \n        require(referrer != address(0), \"ADDRESS_0\");\n\n        ReferrerDetails storage r = referrerDetails[referrer];      \n        require(!r.active, \"REFERRER_ALREADY_ACTIVE\");\n\n        r.active = true;\n        \n        if(ally != address(0)){\n            AllyDetails storage a = allyDetails[ally];\n            require(a.active, \"ALLY_NOT_ACTIVE\");\n\n            r.ally = ally;\n            a.referrersReferred.push(referrer);\n        }\n\n        emit ReferrerWhitelisted(referrer, ally);\n    }\n    function unwhitelistReferrer(address referrer) external onlyGov{\n        ReferrerDetails storage r = referrerDetails[referrer];\n        require(r.active, \"ALREADY_UNACTIVE\");\n\n        r.active = false;\n\n        emit ReferrerUnwhitelisted(referrer);\n    }\n\n    function registerPotentialReferrer(\n        address trader,\n        address referrer\n    ) external onlyTrading{\n\n        ReferrerDetails storage r = referrerDetails[referrer];\n\n        if(referrerByTrader[trader] != address(0)\n        || referrer == address(0)\n        || !r.active){\n            return;\n        }\n\n        referrerByTrader[trader] = referrer;\n        r.tradersReferred.push(trader);\n\n        emit ReferrerRegistered(trader, referrer);\n    }\n\n    // REWARDS DISTRIBUTION\n    function distributePotentialReward(\n        address trader,\n        uint volumeWETH,\n        uint pairOpenFeeP,\n        uint tokenPriceWETH\n    ) external onlyCallbacks returns(uint){\n\n        address referrer = referrerByTrader[trader];\n        ReferrerDetails storage r = referrerDetails[referrer];\n\n        if(!r.active){\n            return 0;\n        }\n\n        uint referrerRewardValueWETH = volumeWETH * getReferrerFeeP(\n            pairOpenFeeP,\n            r.volumeReferredWETH\n        ) / PRECISION / 100;\n\n        uint referrerRewardToken = referrerRewardValueWETH * PRECISION / tokenPriceWETH;\n\n        storageT.handleTokens(address(this), referrerRewardToken, true);\n\n        AllyDetails storage a = allyDetails[r.ally];\n        \n        uint allyRewardValueWETH;\n        uint allyRewardToken;\n\n        if(a.active){\n            allyRewardValueWETH = referrerRewardValueWETH * allyFeeP / 100;\n            allyRewardToken = referrerRewardToken * allyFeeP / 100;\n\n            a.volumeReferredWETH += volumeWETH;\n            a.pendingRewardsToken += allyRewardToken;\n            a.totalRewardsToken += allyRewardToken;\n            a.totalRewardsValueWETH += allyRewardValueWETH;\n\n            referrerRewardValueWETH -= allyRewardValueWETH;\n            referrerRewardToken -= allyRewardToken;\n\n            emit AllyRewardDistributed(\n                r.ally,\n                trader,\n                volumeWETH,\n                allyRewardToken,\n                allyRewardValueWETH\n            );\n        }\n\n        r.volumeReferredWETH += volumeWETH;\n        r.pendingRewardsToken += referrerRewardToken;\n        r.totalRewardsToken += referrerRewardToken;\n        r.totalRewardsValueWETH += referrerRewardValueWETH;\n\n        emit ReferrerRewardDistributed(\n            referrer,\n            trader,\n            volumeWETH,\n            referrerRewardToken,\n            referrerRewardValueWETH\n        );\n\n        return referrerRewardValueWETH + allyRewardValueWETH;\n    }\n\n    // REWARDS CLAIMING\n    function claimAllyRewards() external{\n        AllyDetails storage a = allyDetails[msg.sender];\n        uint rewardsToken = a.pendingRewardsToken;\n        \n        require(rewardsToken > 0, \"NO_PENDING_REWARDS\");\n\n        a.pendingRewardsToken = 0;\n        storageT.token().transfer(msg.sender, rewardsToken);\n\n        emit AllyRewardsClaimed(msg.sender, rewardsToken);\n    }\n    function claimReferrerRewards() external{\n        ReferrerDetails storage r = referrerDetails[msg.sender];\n        uint rewardsToken = r.pendingRewardsToken;\n        \n        require(rewardsToken > 0, \"NO_PENDING_REWARDS\");\n\n        r.pendingRewardsToken = 0;\n        storageT.token().transfer(msg.sender, rewardsToken);\n\n        emit ReferrerRewardsClaimed(msg.sender, rewardsToken);\n    }\n\n    // VIEW FUNCTIONS\n    function getReferrerFeeP(\n        uint pairOpenFeeP,\n        uint volumeReferredWETH\n    ) public view returns(uint){\n\n        uint maxReferrerFeeP = pairOpenFeeP * 2 * openFeeP / 100;\n        uint minFeeP = maxReferrerFeeP * startReferrerFeeP / 100;\n\n        uint feeP = minFeeP + (maxReferrerFeeP - minFeeP)\n            * volumeReferredWETH / 1e18 / targetVolumeWETH;\n\n        return feeP > maxReferrerFeeP ? maxReferrerFeeP : feeP;\n    }\n\n    function getPercentOfOpenFeeP(\n        address trader\n    ) external view returns(uint){\n        return getPercentOfOpenFeeP_calc(referrerDetails[referrerByTrader[trader]].volumeReferredWETH);\n    }\n\n    function getPercentOfOpenFeeP_calc(\n        uint volumeReferredWETH\n    ) public view returns(uint resultP){\n        resultP = (openFeeP * (\n            startReferrerFeeP * PRECISION +\n            volumeReferredWETH * PRECISION * (100 - startReferrerFeeP) / 1e18 / targetVolumeWETH)\n        ) / 100;\n\n        resultP = resultP > openFeeP * PRECISION ?\n            openFeeP * PRECISION :\n            resultP;\n    }\n\n    function getTraderReferrer(\n        address trader\n    ) external view returns(address){\n        address referrer = referrerByTrader[trader];\n\n        return referrerDetails[referrer].active ? referrer : address(0);\n    }\n    function getReferrersReferred(\n        address ally\n    ) external view returns (address[] memory){\n        return allyDetails[ally].referrersReferred;\n    }\n    function getTradersReferred(\n        address referred\n    ) external view returns (address[] memory){\n        return referrerDetails[referred].tradersReferred;\n    }\n}"
    },
    "contracts/contracts6_2/GNSStakingV6_2.sol": {
      "content": "/**\n *Submitted for verification at PolygonScan.com on 2022-08-16\n*/\n\n/// DEPLOY need g token and WETH\n\n// File: contracts\\interfaces\\TokenInterfaceV5.sol\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\ninterface TokenInterfaceV5{\n    function burn(address, uint256) external;\n    function mint(address, uint256) external;\n    function transfer(address, uint256) external returns (bool);\n    function transferFrom(address, address, uint256) external returns(bool);\n    function balanceOf(address) external view returns(uint256);\n    function hasRole(bytes32, address) external view returns (bool);\n    function approve(address, uint256) external returns (bool);\n    function allowance(address, address) external view returns (uint256);\n}\n\n// File: contracts\\interfaces\\NftInterfaceV5.sol\n\npragma solidity 0.8.15;\n\ninterface NftInterfaceV5{\n    function balanceOf(address) external view returns (uint);\n    function ownerOf(uint) external view returns (address);\n    function transferFrom(address, address, uint) external;\n    function tokenOfOwnerByIndex(address, uint) external view returns(uint);\n}\n\n// File: contracts\\GNSStakingV6_2.sol\n\npragma solidity 0.8.15;\n\ncontract GNSStakingV6_2 {\n\n    // Contracts & Addresses\n    address public govFund;\n\n    TokenInterfaceV5 public immutable token; // GNS\n    TokenInterfaceV5 public immutable WETH;\n\n    NftInterfaceV5[5] public nfts;\n\n    // Pool state\n    uint public accWETHPerToken;\n    uint public tokenBalance;\n\n    // Pool parameters\n    uint[5] public boostsP;\n    uint public maxNftsStaked;\n\n    // Pool stats\n    uint public totalRewardsDistributedWETH; // 1e18\n\n    // Mappings\n    mapping(address => User) public users;\n    mapping(address => mapping(uint => StakedNft)) public userNfts;\n\n    // Structs\n    struct StakedNft{\n        uint nftId;\n        uint nftType;\n    }\n    struct User{\n        uint stakedTokens;        // 1e18\n        uint debtWETH;             // 1e18\n        uint stakedNftsCount;\n        uint totalBoostTokens;    // 1e18\n        uint harvestedRewardsWETH; // 1e18\n    }\n\n    // Events\n    event GovFundUpdated(address value);\n    event BoostsUpdated(uint[5] boosts);\n    event MaxNftsStakedUpdated(uint value);\n\n    event WETHDistributed(uint amount);\n\n    event WETHHarvested(\n        address indexed user,\n        uint amount\n    );\n\n    event TokensStaked(\n        address indexed user,\n        uint amount\n    );\n    event TokensUnstaked(\n        address indexed user,\n        uint amount\n    );\n\n    event NftStaked(\n        address indexed user,\n        uint indexed nftType,\n        uint nftId\n    );\n    event NftUnstaked(\n        address indexed user,\n        uint indexed nftType,\n        uint nftId\n    );\n\n    constructor(\n        address _govFund, \n        TokenInterfaceV5 _token,\n        TokenInterfaceV5 _WETH,\n        NftInterfaceV5[5] memory _nfts,\n        uint[5] memory _boostsP,\n        uint _maxNftsStaked\n    ){\n        require(_govFund != address(0)\n            && address(_token) != address(0)\n            && address(_WETH) != address(0)\n            && address(_nfts[4]) != address(0), \"WRONG_PARAMS\");\n\n        checkBoostsP(_boostsP);\n\n        govFund = _govFund;\n        token = _token;\n        WETH = _WETH;\n        nfts = _nfts;\n\n        boostsP = _boostsP;\n        maxNftsStaked = _maxNftsStaked;\n    }\n\n    // Modifiers\n    modifier onlyGov(){\n        require(msg.sender == govFund, \"GOV_ONLY\");\n        _;\n    }\n    modifier notContract(){\n        require(tx.origin == msg.sender, \"CONTRACT\");\n        _;\n    }\n\n    // Manage addresses\n    function setGovFund(address value) external onlyGov{\n        require(value != address(0), \"ADDRESS_0\");\n\n        govFund = value;\n\n        emit GovFundUpdated(value);\n    }\n\n    // Manage parameters\n    function checkBoostsP(uint[5] memory value) public pure{\n        require(value[0] < value[1] && value[1] < value[2]\n            && value[2] < value[3] && value[3] < value[4],\n            \"WRONG_VALUES\");\n    }\n    function setBoostsP(uint[5] memory value) external onlyGov{\n        checkBoostsP(value);\n        \n        boostsP = value;\n\n        emit BoostsUpdated(value);\n    }\n    function setMaxNftsStaked(uint value) external onlyGov{\n        maxNftsStaked = value;\n\n        emit MaxNftsStakedUpdated(value);\n    }\n\n    // Distribute rewards\n    function distributeRewardWETH(uint amount) external{\n        WETH.transferFrom(msg.sender, address(this), amount);\n\n        if(tokenBalance > 0){\n            accWETHPerToken += amount * 1e18 / tokenBalance;\n            totalRewardsDistributedWETH += amount;\n        }\n\n        emit WETHDistributed(amount);\n    }\n\n    // Compute user boosts\n    function setBoosts() private{\n        User storage u = users[msg.sender];\n\n        u.totalBoostTokens = 0;\n\n        for(uint i = 0; i < u.stakedNftsCount; i++){\n            u.totalBoostTokens += u.stakedTokens \n                * boostsP[userNfts[msg.sender][i].nftType - 1] / 100;\n        }\n\n        u.debtWETH = (u.stakedTokens + u.totalBoostTokens) * accWETHPerToken / 1e18;\n    }\n\n    // Rewards to be harvested\n    function pendingRewardWETH() view public returns(uint){\n        User storage u = users[msg.sender];\n\n        return (u.stakedTokens + u.totalBoostTokens)\n            * accWETHPerToken / 1e18 - u.debtWETH;\n    }\n\n    // Harvest rewards\n    function harvest() public{\n        uint pendingWETH = pendingRewardWETH();\n\n        User storage u = users[msg.sender];\n        u.debtWETH = (u.stakedTokens + u.totalBoostTokens) * accWETHPerToken / 1e18;\n        u.harvestedRewardsWETH += pendingWETH;\n\n        WETH.transfer(msg.sender, pendingWETH);\n\n        emit WETHHarvested(msg.sender, pendingWETH);\n    }\n\n    // Stake tokens\n    function stakeTokens(uint amount) external{\n        User storage u = users[msg.sender];\n        \n        token.transferFrom(msg.sender, address(this), amount);\n\n        harvest();\n\n        tokenBalance -= (u.stakedTokens + u.totalBoostTokens);\n\n        u.stakedTokens += amount;\n        setBoosts();\n\n        tokenBalance += (u.stakedTokens + u.totalBoostTokens);\n\n        emit TokensStaked(msg.sender, amount);\n    }\n\n    // Unstake tokens\n    function unstakeTokens(uint amount) external{\n        User storage u = users[msg.sender];\n\n        harvest();\n\n        tokenBalance -= (u.stakedTokens + u.totalBoostTokens);\n\n        u.stakedTokens -= amount;\n        setBoosts();\n\n        tokenBalance += (u.stakedTokens + u.totalBoostTokens);\n\n        token.transfer(msg.sender, amount);\n\n        emit TokensUnstaked(msg.sender, amount);\n    }\n\n    // Stake NFT\n    // NFT types: 1, 2, 3, 4, 5\n    function stakeNft(uint nftType, uint nftId) external notContract{\n        User storage u = users[msg.sender];\n\n        require(u.stakedNftsCount < maxNftsStaked, \"MAX_NFTS_ALREADY_STAKED\");\n\n        nfts[nftType - 1].transferFrom(msg.sender, address(this), nftId);\n\n        harvest();\n\n        tokenBalance -= (u.stakedTokens + u.totalBoostTokens);\n\n        StakedNft storage stakedNft = userNfts[msg.sender][u.stakedNftsCount++];\n        stakedNft.nftType = nftType;\n        stakedNft.nftId = nftId;\n\n        setBoosts();\n\n        tokenBalance += (u.stakedTokens + u.totalBoostTokens);\n\n        emit NftStaked(msg.sender, nftType, nftId);\n    }\n\n    // Unstake NFT\n    function unstakeNft(uint nftIndex) external{\n        User storage u = users[msg.sender];\n        StakedNft memory stakedNft = userNfts[msg.sender][nftIndex];\n\n        harvest();\n\n        tokenBalance -= (u.stakedTokens + u.totalBoostTokens);\n\n        userNfts[msg.sender][nftIndex] = userNfts[msg.sender][u.stakedNftsCount - 1];\n        delete userNfts[msg.sender][(u.stakedNftsCount--) - 1];\n\n        setBoosts();\n\n        tokenBalance += (u.stakedTokens + u.totalBoostTokens);\n\n        nfts[stakedNft.nftType - 1].transferFrom(address(this), msg.sender, stakedNft.nftId);\n\n        emit NftUnstaked(msg.sender, stakedNft.nftType, stakedNft.nftId);\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 125
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}