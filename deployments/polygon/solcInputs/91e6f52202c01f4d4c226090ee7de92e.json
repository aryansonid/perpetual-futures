{
  "language": "Solidity",
  "sources": {
    "contracts/contract6/GNSPairsStorageV6.sol": {
      "content": "/**\n *Submitted for verification at PolygonScan.com on 2022-02-14\n*/\n\n\n/// DEPLOY no dependency.\n// File: contracts\\interfaces\\UniswapRouterInterfaceV5.sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\ninterface UniswapRouterInterfaceV5{\n\tfunction swapExactTokensForTokens(\n\t\tuint amountIn,\n\t\tuint amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external returns (uint[] memory amounts);\n\n\tfunction swapTokensForExactTokens(\n\t\tuint amountOut,\n\t\tuint amountInMax,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external returns (uint[] memory amounts);\n}\n\n// File: contracts\\interfaces\\TokenInterfaceV5.sol\n\npragma solidity 0.8.11;\n\ninterface TokenInterfaceV5{\n    function burn(address, uint256) external;\n    function mint(address, uint256) external;\n    function transfer(address, uint256) external returns (bool);\n    function transferFrom(address, address, uint256) external returns(bool);\n    function balanceOf(address) external view returns(uint256);\n    function hasRole(bytes32, address) external view returns (bool);\n    function approve(address, uint256) external returns (bool);\n    function allowance(address, address) external view returns (uint256);\n}\n\n// File: contracts\\interfaces\\NftInterfaceV5.sol\n\npragma solidity 0.8.11;\n\ninterface NftInterfaceV5{\n    function balanceOf(address) external view returns (uint);\n    function ownerOf(uint) external view returns (address);\n    function transferFrom(address, address, uint) external;\n    function tokenOfOwnerByIndex(address, uint) external view returns(uint);\n}\n\n// File: contracts\\interfaces\\VaultInterfaceV5.sol\n\npragma solidity 0.8.11;\n\ninterface VaultInterfaceV5{\n\tfunction sendWETHToTrader(address, uint) external;\n\tfunction receiveWETHFromTrader(address, uint, uint) external;\n\tfunction currentBalanceWETH() external view returns(uint);\n\tfunction distributeRewardWETH(uint) external;\n}\n\n// File: contracts\\interfaces\\PairsStorageInterfaceV6.sol\n\npragma solidity 0.8.11;\n\ninterface PairsStorageInterfaceV6{\n    enum FeedCalculation { DEFAULT, INVERT, COMBINE }    // FEED 1, 1 / (FEED 1), (FEED 1)/(FEED 2)\n    struct Feed{ address feed1; address feed2; FeedCalculation feedCalculation; uint maxDeviationP; } // PRECISION (%)\n    function incrementCurrentOrderId() external returns(uint);\n    function updateGroupCollateral(uint, uint, bool, bool) external;\n    function pairJob(uint) external returns(string memory, string memory, bytes32, uint);\n    function pairFeed(uint) external view returns(Feed memory);\n    function pairSpreadP(uint) external view returns(uint);\n    function pairMinLeverage(uint) external view returns(uint);\n    function pairMaxLeverage(uint) external view returns(uint);\n    function groupMaxCollateral(uint) external view returns(uint);\n    function groupCollateral(uint, bool) external view returns(uint);\n    function guaranteedSlEnabled(uint) external view returns(bool);\n    function pairOpenFeeP(uint) external view returns(uint);\n    function pairCloseFeeP(uint) external view returns(uint);\n    function pairOracleFeeP(uint) external view returns(uint);\n    function pairNftLimitOrderFeeP(uint) external view returns(uint);\n    function pairReferralFeeP(uint) external view returns(uint);\n    function pairMinLevPosWETH(uint) external view returns(uint);\n}\n\n// File: contracts\\interfaces\\StorageInterfaceV5.sol\n\n\n\n\n\n\npragma solidity 0.8.11;\n\ninterface StorageInterfaceV5{\n    enum LimitOrder { TP, SL, LIQ, OPEN }\n    struct Trader{\n        uint leverageUnlocked;\n        address referral;\n        uint referralRewardsTotal;  // 1e18\n    }\n    struct Trade{\n        address trader;\n        uint pairIndex;\n        uint index;\n        uint initialPosToken;       // 1e18\n        uint positionSizeWETH;       // 1e18\n        uint openPrice;             // PRECISION\n        bool buy;\n        uint leverage;\n        uint tp;                    // PRECISION\n        uint sl;                    // PRECISION\n    }\n    struct TradeInfo{\n        uint tokenId;\n        uint tokenPriceWETH;         // PRECISION\n        uint openInterestWETH;       // 1e18\n        uint tpLastUpdated;\n        uint slLastUpdated;\n        bool beingMarketClosed;\n    }\n    struct OpenLimitOrder{\n        address trader;\n        uint pairIndex;\n        uint index;\n        uint positionSize;          // 1e18 (WETH or GFARM2)\n        uint spreadReductionP;\n        bool buy;\n        uint leverage;\n        uint tp;                    // PRECISION (%)\n        uint sl;                    // PRECISION (%)\n        uint minPrice;              // PRECISION\n        uint maxPrice;              // PRECISION\n        uint block;\n        uint tokenId;               // index in supportedTokens\n    }\n    struct PendingMarketOrder{\n        Trade trade;\n        uint block;\n        uint wantedPrice;           // PRECISION\n        uint slippageP;             // PRECISION (%)\n        uint spreadReductionP;\n        uint tokenId;               // index in supportedTokens\n    }\n    struct PendingNftOrder{\n        address nftHolder;\n        uint nftId;\n        address trader;\n        uint pairIndex;\n        uint index;\n        LimitOrder orderType;\n    }\n    function PRECISION() external pure returns(uint);\n    function gov() external view returns(address);\n    function dev() external view returns(address);\n    function WETH() external view returns(TokenInterfaceV5);\n    function token() external view returns(TokenInterfaceV5);\n    function linkErc677() external view returns(TokenInterfaceV5);\n    function tokenWETHRouter() external view returns(UniswapRouterInterfaceV5);\n    function priceAggregator() external view returns(AggregatorInterfaceV6);\n    function vault() external view returns(VaultInterfaceV5);\n    function trading() external view returns(address);\n    function callbacks() external view returns(address);\n    function handleTokens(address,uint,bool) external;\n    function transferWETH(address, address, uint) external;\n    function transferLinkToAggregator(address, uint, uint) external;\n    function unregisterTrade(address, uint, uint) external;\n    function unregisterPendingMarketOrder(uint, bool) external;\n    function unregisterOpenLimitOrder(address, uint, uint) external;\n    function hasOpenLimitOrder(address, uint, uint) external view returns(bool);\n    function storePendingMarketOrder(PendingMarketOrder memory, uint, bool) external;\n    function storeReferral(address, address) external;\n    function openTrades(address, uint, uint) external view returns(Trade memory);\n    function openTradesInfo(address, uint, uint) external view returns(TradeInfo memory);\n    function updateSl(address, uint, uint, uint) external;\n    function updateTp(address, uint, uint, uint) external;\n    function getOpenLimitOrder(address, uint, uint) external view returns(OpenLimitOrder memory);\n    function spreadReductionsP(uint) external view returns(uint);\n    function positionSizeTokenDynamic(uint,uint) external view returns(uint);\n    function maxSlP() external view returns(uint);\n    function storeOpenLimitOrder(OpenLimitOrder memory) external;\n    function reqID_pendingMarketOrder(uint) external view returns(PendingMarketOrder memory);\n    function storePendingNftOrder(PendingNftOrder memory, uint) external;\n    function updateOpenLimitOrder(OpenLimitOrder calldata) external;\n    function firstEmptyTradeIndex(address, uint) external view returns(uint);\n    function firstEmptyOpenLimitIndex(address, uint) external view returns(uint);\n    function increaseNftRewards(uint, uint) external;\n    function nftSuccessTimelock() external view returns(uint);\n    function currentPercentProfit(uint,uint,bool,uint) external view returns(int);\n    function reqID_pendingNftOrder(uint) external view returns(PendingNftOrder memory);\n    function setNftLastSuccess(uint) external;\n    function updateTrade(Trade memory) external;\n    function nftLastSuccess(uint) external view returns(uint);\n    function unregisterPendingNftOrder(uint) external;\n    function handleDevGovFees(uint, uint, bool, bool) external returns(uint);\n    function distributeLpRewards(uint) external;\n    function getReferral(address) external view returns(address);\n    function increaseReferralRewards(address, uint) external;\n    function storeTrade(Trade memory, TradeInfo memory) external;\n    function setLeverageUnlocked(address, uint) external;\n    function getLeverageUnlocked(address) external view returns(uint);\n    function openLimitOrdersCount(address, uint) external view returns(uint);\n    function maxOpenLimitOrdersPerPair() external view returns(uint);\n    function openTradesCount(address, uint) external view returns(uint);\n    function pendingMarketOpenCount(address, uint) external view returns(uint);\n    function pendingMarketCloseCount(address, uint) external view returns(uint);\n    function maxTradesPerPair() external view returns(uint);\n    function maxTradesPerBlock() external view returns(uint);\n    function tradesPerBlock(uint) external view returns(uint);\n    function pendingOrderIdsCount(address) external view returns(uint);\n    function maxPendingMarketOrders() external view returns(uint);\n    function maxGainP() external view returns(uint);\n    function defaultLeverageUnlocked() external view returns(uint);\n    function openInterestWETH(uint, uint) external view returns(uint);\n    function getPendingOrderIds(address) external view returns(uint[] memory);\n    function traders(address) external view returns(Trader memory);\n    function nfts(uint) external view returns(NftInterfaceV5);\n}\n\ninterface AggregatorInterfaceV6{\n    enum OrderType { MARKET_OPEN, MARKET_CLOSE, LIMIT_OPEN, LIMIT_CLOSE, UPDATE_SL }\n    function pairsStorage() external view returns(PairsStorageInterfaceV6);\n    function nftRewards() external view returns(NftRewardsInterfaceV6);\n    function getPrice(uint,OrderType,uint) external returns(uint);\n    function tokenPriceWETH() external view returns(uint);\n    function linkFee(uint,uint) external view returns(uint);\n    function tokenWETHReservesLp() external view returns(uint, uint);\n    function pendingSlOrders(uint) external view returns(PendingSl memory);\n    function storePendingSlOrder(uint orderId, PendingSl calldata p) external;\n    function unregisterPendingSlOrder(uint orderId) external;\n    struct PendingSl{address trader; uint pairIndex; uint index; uint openPrice; bool buy; uint newSl; }\n}\n\ninterface NftRewardsInterfaceV6{\n    struct TriggeredLimitId{ address trader; uint pairIndex; uint index; StorageInterfaceV5.LimitOrder order; }\n    enum OpenLimitOrderType{ LEGACY, REVERSAL, MOMENTUM }\n    function storeFirstToTrigger(TriggeredLimitId calldata, address) external;\n    function storeTriggerSameBlock(TriggeredLimitId calldata, address) external;\n    function unregisterTrigger(TriggeredLimitId calldata) external;\n    function distributeNftReward(TriggeredLimitId calldata, uint) external;\n    function openLimitOrderTypes(address, uint, uint) external view returns(OpenLimitOrderType);\n    function setOpenLimitOrderType(address, uint, uint, OpenLimitOrderType) external;\n    function triggered(TriggeredLimitId calldata) external view returns(bool);\n    function timedOut(TriggeredLimitId calldata) external view returns(bool);\n}\n\n// File: contracts\\GNSPairStorageV6.sol\n\n\npragma solidity 0.8.11;\n\ncontract GNSPairsStorageV6 {\n\n    // Contracts (constant)\n    StorageInterfaceV5 constant storageT = StorageInterfaceV5(0xaee4d11a16B2bc65EDD6416Fb626EB404a6D65BD);\n\n    // Params (constant)\n    uint constant MIN_LEVERAGE = 2;\n    uint constant MAX_LEVERAGE = 1000;\n\n    // Custom data types\n    enum FeedCalculation { DEFAULT, INVERT, COMBINE }\n    struct Feed{ address feed1; address feed2; FeedCalculation feedCalculation; uint maxDeviationP; } // PRECISION (%)\n\n    struct Pair{\n        string from;\n        string to;\n        Feed feed;\n        uint spreadP;               // PRECISION\n        uint groupIndex;\n        uint feeIndex;\n    }\n    struct Group{\n        string name;\n        bytes32 job;\n        uint minLeverage;\n        uint maxLeverage;\n        uint maxCollateralP;        // % (of WETH vault current balance)\n    }\n    struct Fee{\n        string name;\n        uint openFeeP;              // PRECISION (% of leveraged pos)\n        uint closeFeeP;             // PRECISION (% of leveraged pos)\n        uint oracleFeeP;            // PRECISION (% of leveraged pos)\n        uint nftLimitOrderFeeP;     // PRECISION (% of leveraged pos)\n        uint referralFeeP;          // PRECISION (% of leveraged pos)\n        uint minLevPosWETH;          // 1e18 (collateral x leverage, useful for min fee)\n    }\n\n    // State\n    uint public currentOrderId;\n\n    uint public pairsCount;\n    uint public groupsCount;\n    uint public feesCount;\n\n    mapping(uint => Pair) public pairs;\n    mapping(uint => Group) public groups;\n    mapping(uint => Fee) public fees;\n\n    mapping(string => mapping(string => bool)) public isPairListed;\n\n    mapping(uint => uint[2]) public groupsCollaterals; // (long, short)\n\n    // Events\n    event PairAdded(uint index, string from, string to);\n    event PairUpdated(uint index);\n\n    event GroupAdded(uint index, string name);\n    event GroupUpdated(uint index);\n    \n    event FeeAdded(uint index, string name);\n    event FeeUpdated(uint index);\n\n    constructor(uint _currentOrderId) {\n        require(_currentOrderId > 0, \"ORDER_ID_0\");\n        currentOrderId = _currentOrderId;\n    }\n\n    // Modifiers\n    modifier onlyGov(){ require(msg.sender == storageT.gov(), \"GOV_ONLY\"); _; }\n    \n    modifier groupListed(uint _groupIndex){\n        require(groups[_groupIndex].minLeverage > 0, \"GROUP_NOT_LISTED\");\n        _;\n    }\n    modifier feeListed(uint _feeIndex){\n        require(fees[_feeIndex].openFeeP > 0, \"FEE_NOT_LISTED\");\n        _;\n    }\n\n    modifier feedOk(Feed calldata _feed){\n        require(_feed.maxDeviationP > 0 && _feed.feed1 != address(0), \"WRONG_FEED\");\n        require(_feed.feedCalculation != FeedCalculation.COMBINE || _feed.feed2 != address(0), \"FEED_2_MISSING\");\n        _;\n    }\n    modifier groupOk(Group calldata _group){\n        require(_group.job != bytes32(0), \"JOB_EMPTY\");\n        require(_group.minLeverage >= MIN_LEVERAGE && _group.maxLeverage <= MAX_LEVERAGE\n            && _group.minLeverage < _group.maxLeverage, \"WRONG_LEVERAGES\");\n        _;\n    }\n    modifier feeOk(Fee calldata _fee){\n        require(_fee.openFeeP > 0 && _fee.closeFeeP > 0 && _fee.oracleFeeP > 0\n            && _fee.nftLimitOrderFeeP > 0 && _fee.referralFeeP > 0 && _fee.minLevPosWETH > 0, \"WRONG_FEES\");\n        _;\n    }\n\n    // Manage pairs\n    function addPair(Pair calldata _pair) public onlyGov feedOk(_pair.feed) groupListed(_pair.groupIndex) feeListed(_pair.feeIndex){\n        require(!isPairListed[_pair.from][_pair.to], \"PAIR_ALREADY_LISTED\");\n        \n        pairs[pairsCount] = _pair;\n        isPairListed[_pair.from][_pair.to] = true;\n        \n        emit PairAdded(pairsCount++, _pair.from, _pair.to);\n    }\n    function addPairs(Pair[] calldata _pairs) external{\n        for(uint i = 0; i < _pairs.length; i++){\n            addPair(_pairs[i]);\n        }\n    }\n    function updatePair(uint _pairIndex, Pair calldata _pair) external onlyGov feedOk(_pair.feed) feeListed(_pair.feeIndex){\n        Pair storage p = pairs[_pairIndex];\n        require(isPairListed[p.from][p.to], \"PAIR_NOT_LISTED\");\n\n        p.feed = _pair.feed;\n        p.spreadP = _pair.spreadP;\n        p.feeIndex = _pair.feeIndex;\n        \n        emit PairUpdated(_pairIndex);\n    }\n\n    // Manage groups\n    function addGroup(Group calldata _group) external onlyGov groupOk(_group){\n        groups[groupsCount] = _group;\n        emit GroupAdded(groupsCount++, _group.name);\n    }\n    function updateGroup(uint _id, Group calldata _group) external onlyGov groupListed(_id) groupOk(_group){\n        groups[_id] = _group;\n        emit GroupUpdated(_id);\n    }\n\n    // Manage fees\n    function addFee(Fee calldata _fee) external onlyGov feeOk(_fee){\n        fees[feesCount] = _fee;\n        emit FeeAdded(feesCount++, _fee.name);\n    }\n    function updateFee(uint _id, Fee calldata _fee) external onlyGov feeListed(_id) feeOk(_fee){\n        fees[_id] = _fee;\n        emit FeeUpdated(_id);\n    }\n\n    // Update collateral open exposure for a group (callbacks)\n    function updateGroupCollateral(uint _pairIndex, uint _amount, bool _long, bool _increase) external{\n        require(msg.sender == storageT.callbacks(), \"CALLBACKS_ONLY\");\n\n        uint[2] storage collateralOpen = groupsCollaterals[pairs[_pairIndex].groupIndex];\n        uint index = _long ? 0 : 1;\n\n        if(_increase){\n            collateralOpen[index] += _amount;\n        }else{\n            collateralOpen[index] = collateralOpen[index] > _amount ? collateralOpen[index] - _amount : 0;\n        }\n    }\n\n    // Fetch relevant info for order (aggregator)\n    function pairJob(uint _pairIndex) external returns(string memory, string memory, bytes32, uint){\n        require(msg.sender == address(storageT.priceAggregator()), \"AGGREGATOR_ONLY\");\n        \n        Pair memory p = pairs[_pairIndex];\n        require(isPairListed[p.from][p.to], \"PAIR_NOT_LISTED\");\n        \n        return (p.from, p.to, groups[p.groupIndex].job, currentOrderId++);\n    }\n\n    // Getters (pairs & groups)\n    function pairFeed(uint _pairIndex) external view returns(Feed memory){\n        return pairs[_pairIndex].feed;\n    }\n    function pairSpreadP(uint _pairIndex) external view returns(uint){\n        return pairs[_pairIndex].spreadP;\n    }\n    function pairMinLeverage(uint _pairIndex) external view returns(uint){\n        return groups[pairs[_pairIndex].groupIndex].minLeverage;\n    }\n    function pairMaxLeverage(uint _pairIndex) external view returns(uint){\n        return groups[pairs[_pairIndex].groupIndex].maxLeverage;\n    }\n    function groupMaxCollateral(uint _pairIndex) external view returns(uint){\n        return groups[pairs[_pairIndex].groupIndex].maxCollateralP*storageT.vault().currentBalanceWETH()/100;\n    }\n    function groupCollateral(uint _pairIndex, bool _long) external view returns(uint){\n        return groupsCollaterals[pairs[_pairIndex].groupIndex][_long ? 0 : 1];\n    }\n    function guaranteedSlEnabled(uint _pairIndex) external view returns(bool){\n        return pairs[_pairIndex].groupIndex == 0; // crypto only\n    }\n\n    // Getters (fees)\n    function pairOpenFeeP(uint _pairIndex) external view returns(uint){ \n        return fees[pairs[_pairIndex].feeIndex].openFeeP;\n    }\n    function pairCloseFeeP(uint _pairIndex) external view returns(uint){ \n        return fees[pairs[_pairIndex].feeIndex].closeFeeP; \n    }\n    function pairOracleFeeP(uint _pairIndex) external view returns(uint){ \n        return fees[pairs[_pairIndex].feeIndex].oracleFeeP; \n    }\n    function pairNftLimitOrderFeeP(uint _pairIndex) external view returns(uint){ \n        return fees[pairs[_pairIndex].feeIndex].nftLimitOrderFeeP; \n    }\n    function pairReferralFeeP(uint _pairIndex) external view returns(uint){ \n        return fees[pairs[_pairIndex].feeIndex].referralFeeP; \n    }\n    function pairMinLevPosWETH(uint _pairIndex) external view returns(uint){\n        return fees[pairs[_pairIndex].feeIndex].minLevPosWETH;\n    }\n\n    // Getters (backend)\n    function pairsBackend(uint _index) external view returns(Pair memory, Group memory, Fee memory){\n        Pair memory p = pairs[_index];\n        return (p, groups[p.groupIndex], fees[p.feeIndex]);\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 125
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}