{
  "language": "Solidity",
  "sources": {
    "contracts/Oracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\ncontract Oracle {\n    struct Observation {\n        // the block timestamp of the last updation\n        uint256 lastUpdateblockTimestamp;\n        // the price accumelator\n        uint256 priceCumulative;\n        // the seconds cummelated for every price update\n        uint256 secondsPerLiquidityCumulative;\n        // initialize time\n        uint256 initializeTime;\n    }\n\n    mapping(uint256 => Observation) priceData;\n\n    function transformPriceData(\n        Observation memory last,\n        uint256 blockTimestamp,\n        uint256 price\n    ) private pure returns (Observation memory) {\n        uint256 delta = blockTimestamp - last.lastUpdateblockTimestamp;\n        return\n            Observation({\n                lastUpdateblockTimestamp: blockTimestamp,\n                priceCumulative: last.priceCumulative + (price * delta),\n                secondsPerLiquidityCumulative: last\n                    .secondsPerLiquidityCumulative + delta,\n                initializeTime: last.initializeTime\n            });\n    }\n\n    function initializePriceData(\n        uint256 blockTimestamp,\n        uint256 price\n    ) private pure returns (Observation memory) {\n        return\n            Observation({\n                lastUpdateblockTimestamp: blockTimestamp,\n                priceCumulative: price,\n                secondsPerLiquidityCumulative: 1,\n                initializeTime: blockTimestamp\n            });\n    }\n\n    function feedPrice(uint256 tokenIndex, uint256 price) public {\n        Observation memory last = priceData[tokenIndex];\n        uint256 initializatonDelta = block.timestamp - last.initializeTime;\n        Observation memory upadate;\n        if (\n            initializatonDelta < 8 hours &&\n            !(initializatonDelta == block.timestamp)\n        ) {\n            upadate = transformPriceData(last, block.timestamp, price);\n        } else {\n            upadate = initializePriceData(block.timestamp, price);\n        }\n        priceData[tokenIndex] = upadate;\n    }\n\n    function feedPriceArray(\n        uint256[] calldata tokenIndexes,\n        uint256[] calldata prices\n    ) external {\n        for (uint256 i; i < tokenIndexes.length; i++) {\n            feedPrice(tokenIndexes[i], prices[i]);\n        }\n    }\n\n    function getTWAP(\n        uint256 tokenIndex\n    ) external view returns (uint256 twapPrice) {\n        Observation memory tokenPriceData = priceData[tokenIndex];\n        require(tokenPriceData.secondsPerLiquidityCumulative != 0, \"price feed not set\");\n        twapPrice =\n            tokenPriceData.priceCumulative /\n            tokenPriceData.secondsPerLiquidityCumulative;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 125
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}