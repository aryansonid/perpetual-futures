{
  "language": "Solidity",
  "sources": {
    "contracts/contract5/GFarmTradingStorageV5.sol": {
      "content": "/**\n *Submitted for verification at PolygonScan.com on 2021-10-12\n */\n\n// File: contracts\\interfaces\\TokenInterfaceV5.sol\n\n/// DEPLOY: could be deployed independently\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\ninterface TokenInterfaceV5 {\n    function burn(address, uint256) external;\n\n    function mint(address, uint256) external;\n\n    function transfer(address, uint256) external returns (bool);\n\n    function transferFrom(address, address, uint256) external returns (bool);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function hasRole(bytes32, address) external view returns (bool);\n\n    function approve(address, uint256) external returns (bool);\n\n    function allowance(address, address) external view returns (uint256);\n}\n\n// File: contracts\\interfaces\\AggregatorInterfaceV5.sol\n\npragma solidity 0.8.7;\n\ninterface AggregatorInterfaceV5 {\n    enum OrderType {\n        MARKET_OPEN,\n        MARKET_CLOSE,\n        LIMIT_OPEN,\n        LIMIT_CLOSE\n    }\n\n    function getPrice(uint, OrderType, uint) external returns (uint);\n\n    function tokenPriceWETH() external view returns (uint);\n\n    function pairMinOpenLimitSlippageP(uint) external view returns (uint);\n\n    function closeFeeP(uint) external view returns (uint);\n\n    function linkFee(uint, uint) external view returns (uint);\n\n    function openFeeP(uint) external view returns (uint);\n\n    function pairMinLeverage(uint) external view returns (uint);\n\n    function pairMaxLeverage(uint) external view returns (uint);\n\n    function pairsCount() external view returns (uint);\n\n    function tokenWETHReservesLp() external view returns (uint, uint);\n\n    function referralP(uint) external view returns (uint);\n\n    function nftLimitOrderFeeP(uint) external view returns (uint);\n}\n\n// File: contracts\\interfaces\\PoolInterfaceV5.sol\n\npragma solidity 0.8.7;\n\ninterface PoolInterfaceV5 {\n    function increaseAccTokensPerLp(uint) external;\n}\n\n// File: contracts\\interfaces\\NftInterfaceV5.sol\n\npragma solidity 0.8.7;\n\ninterface NftInterfaceV5 {\n    function balanceOf(address) external view returns (uint);\n\n    function ownerOf(uint) external view returns (address);\n\n    function transferFrom(address, address, uint) external;\n\n    function tokenOfOwnerByIndex(address, uint) external view returns (uint);\n}\n\n// File: contracts\\interfaces\\PausableInterfaceV5.sol\n\npragma solidity 0.8.7;\n\ninterface PausableInterfaceV5 {\n    function isPaused() external view returns (bool);\n}\n\n// File: contracts\\GFarmTradingStorageV5.sol\n\npragma solidity 0.8.7;\n\ncontract GFarmTradingStorageV5 {\n    // Constants\n    uint public constant PRECISION = 1e10;\n    bytes32 public constant MINTER_ROLE =\n        0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6;\n    TokenInterfaceV5 public WETH;\n    TokenInterfaceV5 public constant linkErc677 =\n        TokenInterfaceV5(0xb0897686c545045aFc77CF20eC7A532E3120E0F1);\n\n    // Contracts (updatable)\n    AggregatorInterfaceV5 public priceAggregator;\n    PoolInterfaceV5 public pool;\n    PausableInterfaceV5 public trading;\n    PausableInterfaceV5 public callbacks;\n    TokenInterfaceV5 public token =\n        TokenInterfaceV5(0x7075cAB6bCCA06613e2d071bd918D1a0241379E2);\n    NftInterfaceV5[5] public nfts = [\n        NftInterfaceV5(0xF9A4c522E327935BD1F5a338c121E14e4cc1f898),\n        NftInterfaceV5(0x77cd42B925e1A82f41d852D6BE727CFc88fddBbC),\n        NftInterfaceV5(0x3378AD81D09DE23725Ee9B9270635c97Ed601921),\n        NftInterfaceV5(0x02e2c5825C1a3b69C0417706DbE1327C2Af3e6C2),\n        NftInterfaceV5(0x2D266A94469d05C9e06D52A4D0d9C23b157767c2)\n    ];\n    address public vault;\n    address public tokenWETHRouter;\n\n    // Trading variables\n    uint public maxTradesPerPair = 3;\n    uint public maxTradesPerBlock = 5;\n    uint public maxPendingMarketOrders = 5;\n    uint public maxGainP = 900; // %\n    uint public maxSlP = 80; // %\n    uint public defaultLeverageUnlocked = 50; // x\n    uint public nftSuccessTimelock = 50; // 50 blocks\n    uint[5] public spreadReductionsP = [15, 20, 25, 30, 35]; // %\n\n    // Gov & dev addresses (updatable)\n    address public gov = 0xC66FbE50Dd33c9AAdd65707F7088D597C86fE00F; //TODO need to change to our\n    address public dev = 0xd39A38bD2D2d552f3908ff698a5530aa397fb92d; //TODO need to change to our\n\n    // Gov & dev fees\n    uint public devFeesToken; // 1e18\n    uint public devFeesWETH; // 1e18\n    uint public govFeesToken; // 1e18\n    uint public govFeesWETH; // 1e18\n\n    // Stats\n    uint public tokensBurned; // 1e18\n    uint public tokensMinted; // 1e18\n    uint public nftRewards; // 1e18\n\n    // Enums\n    enum LimitOrder {\n        TP,\n        SL,\n        LIQ,\n        OPEN\n    }\n\n    // Structs\n    struct Trader {\n        uint leverageUnlocked;\n        address referral;\n        uint referralRewardsTotal; // 1e18\n    }\n    struct Trade {\n        address trader;\n        uint pairIndex;\n        uint index;\n        uint initialPosToken; // 1e18\n        uint positionSizeWETH; // 1e18\n        uint openPrice; // PRECISION\n        bool buy;\n        uint leverage;\n        uint tp; // PRECISION\n        uint sl; // PRECISION\n    }\n    struct TradeInfo {\n        uint tokenId;\n        uint tokenPriceWETH; // PRECISION\n        uint openInterestWETH; // 1e18\n        uint tpLastUpdated;\n        uint slLastUpdated;\n        bool beingMarketClosed;\n    }\n    struct OpenLimitOrder {\n        address trader;\n        uint pairIndex;\n        uint index;\n        uint positionSize; // 1e18 (WETH or GFARM2)\n        uint spreadReductionP;\n        bool buy;\n        uint leverage;\n        uint tp; // PRECISION (%)\n        uint sl; // PRECISION (%)\n        uint minPrice; // PRECISION\n        uint maxPrice; // PRECISION\n        uint block;\n        uint tokenId; // index in supportedTokens\n    }\n    struct PendingMarketOrder {\n        Trade trade;\n        uint block;\n        uint wantedPrice; // PRECISION\n        uint slippageP; // PRECISION (%)\n        uint spreadReductionP;\n        uint tokenId; // index in supportedTokens\n    }\n    struct PendingNftOrder {\n        address nftHolder;\n        uint nftId;\n        address trader;\n        uint pairIndex;\n        uint index;\n        LimitOrder orderType;\n    }\n\n    // Supported tokens to open trades with\n    address[] public supportedTokens;\n\n    // User info mapping\n    mapping(address => Trader) public traders;\n\n    // Trades mappings\n    mapping(address => mapping(uint => mapping(uint => Trade)))\n        public openTrades;\n    mapping(address => mapping(uint => mapping(uint => TradeInfo)))\n        public openTradesInfo;\n    mapping(address => mapping(uint => uint)) public openTradesCount;\n\n    // Limit orders mappings\n    mapping(address => mapping(uint => mapping(uint => uint)))\n        public openLimitOrderIds;\n    mapping(address => mapping(uint => uint)) public openLimitOrdersCount;\n    OpenLimitOrder[] public openLimitOrders;\n\n    // Pending orders mappings\n    mapping(uint => PendingMarketOrder) public reqID_pendingMarketOrder;\n    mapping(uint => PendingNftOrder) public reqID_pendingNftOrder;\n    mapping(address => uint[]) public pendingOrderIds;\n    mapping(address => mapping(uint => uint)) public pendingMarketOpenCount;\n    mapping(address => mapping(uint => uint)) public pendingMarketCloseCount;\n\n    // List of open trades & limit orders\n    mapping(uint => address[]) public pairTraders;\n    mapping(address => mapping(uint => uint)) public pairTradersId;\n\n    // Current and max open interests for each pair\n    mapping(uint => uint[3]) public openInterestWETH; // 1e18 [long,short,max]\n\n    // Restrictions & Timelocks\n    mapping(uint => uint) public tradesPerBlock;\n    mapping(uint => uint) public nftLastSuccess;\n\n    // List of allowed contracts => can update storage + mint/burn tokens\n    mapping(address => bool) public isTradingContract;\n\n    // Events\n    event SupportedTokenAdded(address a);\n    event TradingContractAdded(address a);\n    event TradingContractRemoved(address a);\n    event AddressUpdated(string name, address a);\n    event NftsUpdated(NftInterfaceV5[5] nfts);\n    event NumberUpdated(string name, uint value);\n    event NumberUpdatedPair(string name, uint pairIndex, uint value);\n    event SpreadReductionsUpdated(uint[5]);\n\n    constructor(address _WETH, address _gov, address _dev) {\n        WETH = TokenInterfaceV5(_WETH);\n        gov = _gov;\n        dev = _dev;\n    }\n\n    // Modifiers\n    modifier onlyGov() {\n        require(msg.sender == gov);\n        _;\n    }\n    modifier onlyTrading() {\n        require(\n            isTradingContract[msg.sender] &&\n                token.hasRole(MINTER_ROLE, msg.sender)\n        );\n        _;\n    }\n\n    // Manage addresses\n    function setGov(address _gov) external onlyGov {\n        require(_gov != address(0));\n        gov = _gov;\n        emit AddressUpdated(\"gov\", _gov);\n    }\n\n    function setDev(address _dev) external onlyGov {\n        require(_dev != address(0));\n        dev = _dev;\n        emit AddressUpdated(\"dev\", _dev);\n    }\n\n    function updateToken(TokenInterfaceV5 _newToken) external onlyGov {\n        require(trading.isPaused() && callbacks.isPaused(), \"NOT_PAUSED\");\n        require(address(_newToken) != address(0));\n        token = _newToken;\n        emit AddressUpdated(\"token\", address(_newToken));\n    }\n\n    function updateNfts(NftInterfaceV5[5] memory _nfts) external onlyGov {\n        require(address(_nfts[0]) != address(0));\n        nfts = _nfts;\n        emit NftsUpdated(_nfts);\n    }\n\n    // Trading + callbacks contracts\n    function addTradingContract(address _trading) external onlyGov {\n        require(token.hasRole(MINTER_ROLE, _trading), \"NOT_MINTER\"); /// TODO : need to have a gtoken type token of our own\n        require(_trading != address(0));\n        isTradingContract[_trading] = true;\n        emit TradingContractAdded(_trading);\n    }\n\n    function removeTradingContract(address _trading) external onlyGov {\n        require(_trading != address(0));\n        isTradingContract[_trading] = false;\n        emit TradingContractRemoved(_trading);\n    }\n\n    function addSupportedToken(address _token) external onlyGov {\n        require(_token != address(0));\n        supportedTokens.push(_token);\n        emit SupportedTokenAdded(_token);\n    }\n\n    function setPriceAggregator(address _aggregator) external onlyGov {\n        require(_aggregator != address(0));\n        priceAggregator = AggregatorInterfaceV5(_aggregator);\n        emit AddressUpdated(\"priceAggregator\", _aggregator);\n    }\n\n    function setPool(address _pool) external onlyGov {\n        require(_pool != address(0));\n        pool = PoolInterfaceV5(_pool);\n        emit AddressUpdated(\"pool\", _pool);\n    }\n\n    function setVault(address _vault) external onlyGov {\n        require(_vault != address(0));\n        vault = _vault;\n        emit AddressUpdated(\"vault\", _vault);\n    }\n\n    function setTrading(address _trading) external onlyGov {\n        require(_trading != address(0));\n        trading = PausableInterfaceV5(_trading);\n        emit AddressUpdated(\"trading\", _trading);\n    }\n\n    function setCallbacks(address _callbacks) external onlyGov {\n        require(_callbacks != address(0));\n        callbacks = PausableInterfaceV5(_callbacks);\n        emit AddressUpdated(\"callbacks\", _callbacks);\n    }\n\n    function setTokenWETHRouter(address _tokenWETHRouter) external onlyGov {\n        require(_tokenWETHRouter != address(0));\n        tokenWETHRouter = _tokenWETHRouter;\n        emit AddressUpdated(\"tokenWETHRouter\", _tokenWETHRouter);\n    }\n\n    // Manage trading variables\n    function setMaxTradesPerBlock(uint _maxTradesPerBlock) external onlyGov {\n        require(_maxTradesPerBlock > 0);\n        maxTradesPerBlock = _maxTradesPerBlock;\n        emit NumberUpdated(\"maxTradesPerBlock\", _maxTradesPerBlock);\n    }\n\n    function setMaxTradesPerPair(uint _maxTradesPerPair) external onlyGov {\n        require(_maxTradesPerPair > 0);\n        maxTradesPerPair = _maxTradesPerPair;\n        emit NumberUpdated(\"maxTradesPerPair\", _maxTradesPerPair);\n    }\n\n    function setMaxPendingMarketOrders(\n        uint _maxPendingMarketOrders\n    ) external onlyGov {\n        require(_maxPendingMarketOrders > 0);\n        maxPendingMarketOrders = _maxPendingMarketOrders;\n        emit NumberUpdated(\"maxPendingMarketOrders\", _maxPendingMarketOrders);\n    }\n\n    function setMaxGainP(uint _max) external onlyGov {\n        require(_max >= 300);\n        maxGainP = _max;\n        emit NumberUpdated(\"maxGainP\", _max);\n    }\n\n    function setDefaultLeverageUnlocked(uint _lev) external onlyGov {\n        require(_lev > 0);\n        defaultLeverageUnlocked = _lev;\n        emit NumberUpdated(\"defaultLeverageUnlocked\", _lev);\n    }\n\n    function setMaxSlP(uint _max) external onlyGov {\n        require(_max >= 50);\n        maxSlP = _max;\n        emit NumberUpdated(\"maxSlP\", _max);\n    }\n\n    function setNftSuccessTimelock(uint _blocks) external onlyGov {\n        nftSuccessTimelock = _blocks;\n        emit NumberUpdated(\"nftSuccessTimelock\", _blocks);\n    }\n\n    function setSpreadReductionsP(uint[5] calldata _r) external onlyGov {\n        require(\n            _r[0] > 0 &&\n                _r[1] > _r[0] &&\n                _r[2] > _r[1] &&\n                _r[3] > _r[2] &&\n                _r[4] > _r[3]\n        );\n        spreadReductionsP = _r;\n        emit SpreadReductionsUpdated(_r);\n    }\n\n    function setMaxOpenInterestWETH(\n        uint _pairIndex,\n        uint _newMaxOpenInterest\n    ) external onlyGov {\n        // Can set max open interest to 0 to pause trading on this pair only\n        openInterestWETH[_pairIndex][2] = _newMaxOpenInterest;\n        emit NumberUpdatedPair(\n            \"maxOpenInterestWETH\",\n            _pairIndex,\n            _newMaxOpenInterest\n        );\n    }\n\n    // Manage stored trades\n    function storeTrade(\n        Trade memory _trade,\n        TradeInfo memory _tradeInfo\n    ) external onlyTrading {\n        _trade.index = firstEmptyTradeIndex(_trade.trader, _trade.pairIndex);\n        openTrades[_trade.trader][_trade.pairIndex][_trade.index] = _trade;\n\n        openTradesCount[_trade.trader][_trade.pairIndex]++;\n        tradesPerBlock[block.number]++;\n\n        if (openTradesCount[_trade.trader][_trade.pairIndex] == 1) {\n            pairTradersId[_trade.trader][_trade.pairIndex] = pairTraders[\n                _trade.pairIndex\n            ].length;\n            pairTraders[_trade.pairIndex].push(_trade.trader);\n        }\n\n        _tradeInfo.beingMarketClosed = false;\n        openTradesInfo[_trade.trader][_trade.pairIndex][\n            _trade.index\n        ] = _tradeInfo;\n\n        updateOpenInterestWETH(\n            _trade.pairIndex,\n            _tradeInfo.openInterestWETH,\n            true,\n            _trade.buy\n        );\n    }\n\n    function unregisterTrade(\n        address trader,\n        uint pairIndex,\n        uint index\n    ) external onlyTrading {\n        Trade storage t = openTrades[trader][pairIndex][index];\n        TradeInfo storage i = openTradesInfo[trader][pairIndex][index];\n        if (t.leverage == 0) {\n            return;\n        }\n\n        updateOpenInterestWETH(pairIndex, i.openInterestWETH, false, t.buy);\n\n        if (openTradesCount[trader][pairIndex] == 1) {\n            uint _pairTradersId = pairTradersId[trader][pairIndex];\n            address[] storage p = pairTraders[pairIndex];\n\n            p[_pairTradersId] = p[p.length - 1];\n            pairTradersId[p[_pairTradersId]][pairIndex] = _pairTradersId;\n\n            delete pairTradersId[trader][pairIndex];\n            p.pop();\n        }\n\n        delete openTrades[trader][pairIndex][index];\n        delete openTradesInfo[trader][pairIndex][index];\n\n        openTradesCount[trader][pairIndex]--;\n        tradesPerBlock[block.number]++;\n    }\n\n    // Manage pending market orders\n    function storePendingMarketOrder(\n        PendingMarketOrder memory _order,\n        uint _id,\n        bool _open\n    ) external onlyTrading {\n        pendingOrderIds[_order.trade.trader].push(_id);\n\n        reqID_pendingMarketOrder[_id] = _order;\n        reqID_pendingMarketOrder[_id].block = block.number;\n\n        if (_open) {\n            pendingMarketOpenCount[_order.trade.trader][\n                _order.trade.pairIndex\n            ]++;\n        } else {\n            pendingMarketCloseCount[_order.trade.trader][\n                _order.trade.pairIndex\n            ]++;\n            openTradesInfo[_order.trade.trader][_order.trade.pairIndex][\n                _order.trade.index\n            ].beingMarketClosed = true;\n        }\n    }\n\n    function unregisterPendingMarketOrder(\n        uint _id,\n        bool _open\n    ) external onlyTrading {\n        PendingMarketOrder memory _order = reqID_pendingMarketOrder[_id];\n        uint[] storage orderIds = pendingOrderIds[_order.trade.trader];\n\n        for (uint i = 0; i < orderIds.length; i++) {\n            if (orderIds[i] == _id) {\n                if (_open) {\n                    pendingMarketOpenCount[_order.trade.trader][\n                        _order.trade.pairIndex\n                    ]--;\n                } else {\n                    pendingMarketCloseCount[_order.trade.trader][\n                        _order.trade.pairIndex\n                    ]--;\n                    openTradesInfo[_order.trade.trader][_order.trade.pairIndex][\n                        _order.trade.index\n                    ].beingMarketClosed = false;\n                }\n\n                orderIds[i] = orderIds[orderIds.length - 1];\n                orderIds.pop();\n\n                delete reqID_pendingMarketOrder[_id];\n                return;\n            }\n        }\n    }\n\n    // Manage open interest\n    function updateOpenInterestWETH(\n        uint _pairIndex,\n        uint _leveragedPosWETH,\n        bool _open,\n        bool _long\n    ) private {\n        uint index = _long ? 0 : 1;\n        uint[3] storage o = openInterestWETH[_pairIndex];\n        o[index] = _open\n            ? o[index] + _leveragedPosWETH\n            : o[index] - _leveragedPosWETH;\n    }\n\n    // Manage open limit orders\n    function storeOpenLimitOrder(OpenLimitOrder memory o) external onlyTrading {\n        o.index = firstEmptyOpenLimitIndex(o.trader, o.pairIndex);\n        o.block = block.number;\n        openLimitOrders.push(o);\n        openLimitOrderIds[o.trader][o.pairIndex][o.index] =\n            openLimitOrders.length -\n            1;\n        openLimitOrdersCount[o.trader][o.pairIndex]++;\n    }\n\n    function updateOpenLimitOrder(\n        OpenLimitOrder calldata _o\n    ) external onlyTrading {\n        if (!hasOpenLimitOrder(_o.trader, _o.pairIndex, _o.index)) {\n            return;\n        }\n        OpenLimitOrder storage o = openLimitOrders[\n            openLimitOrderIds[_o.trader][_o.pairIndex][_o.index]\n        ];\n        o.positionSize = _o.positionSize;\n        o.buy = _o.buy;\n        o.leverage = _o.leverage;\n        o.tp = _o.tp;\n        o.sl = _o.sl;\n        o.minPrice = _o.minPrice;\n        o.maxPrice = _o.maxPrice;\n        o.block = block.number;\n    }\n\n    function unregisterOpenLimitOrder(\n        address _trader,\n        uint _pairIndex,\n        uint _index\n    ) external onlyTrading {\n        if (!hasOpenLimitOrder(_trader, _pairIndex, _index)) {\n            return;\n        }\n\n        // Copy last order to deleted order => update id of this limit order\n        uint id = openLimitOrderIds[_trader][_pairIndex][_index];\n        openLimitOrders[id] = openLimitOrders[openLimitOrders.length - 1];\n        openLimitOrderIds[openLimitOrders[id].trader][\n            openLimitOrders[id].pairIndex\n        ][openLimitOrders[id].index] = id;\n\n        // Remove\n        delete openLimitOrderIds[_trader][_pairIndex][_index];\n        openLimitOrders.pop();\n\n        openLimitOrdersCount[_trader][_pairIndex]--;\n    }\n\n    // Manage NFT orders\n    function storePendingNftOrder(\n        PendingNftOrder memory _nftOrder,\n        uint _orderId\n    ) external onlyTrading {\n        reqID_pendingNftOrder[_orderId] = _nftOrder;\n    }\n\n    function unregisterPendingNftOrder(uint _order) external onlyTrading {\n        delete reqID_pendingNftOrder[_order];\n    }\n\n    // Manage open trade\n    function updateSl(\n        address _trader,\n        uint _pairIndex,\n        uint _index,\n        uint _newSl\n    ) external onlyTrading {\n        Trade storage t = openTrades[_trader][_pairIndex][_index];\n        TradeInfo storage i = openTradesInfo[_trader][_pairIndex][_index];\n        if (t.leverage == 0) {\n            return;\n        }\n        t.sl = _newSl;\n        i.slLastUpdated = block.number;\n    }\n\n    function updateTp(\n        address _trader,\n        uint _pairIndex,\n        uint _index,\n        uint _newTp\n    ) external onlyTrading {\n        Trade storage t = openTrades[_trader][_pairIndex][_index];\n        TradeInfo storage i = openTradesInfo[_trader][_pairIndex][_index];\n        if (t.leverage == 0) {\n            return;\n        }\n        t.tp = _newTp;\n        i.tpLastUpdated = block.number;\n    }\n\n    function updateTrade(Trade memory _t) external onlyTrading {\n        // useful when partial adding/closing\n        Trade storage t = openTrades[_t.trader][_t.pairIndex][_t.index];\n        if (t.leverage == 0) {\n            return;\n        }\n        t.initialPosToken = _t.initialPosToken;\n        t.positionSizeWETH = _t.positionSizeWETH;\n        t.openPrice = _t.openPrice;\n        t.leverage = _t.leverage;\n    }\n\n    // Manage referrals\n    function storeReferral(\n        address _trader,\n        address _referral\n    ) external onlyTrading {\n        Trader storage trader = traders[_trader];\n        trader.referral = _referral != address(0) &&\n            trader.referral == address(0) &&\n            _referral != _trader\n            ? _referral\n            : trader.referral;\n    }\n\n    function increaseReferralRewards(\n        address _referral,\n        uint _amount\n    ) external onlyTrading {\n        traders[_referral].referralRewardsTotal += _amount;\n    }\n\n    // Manage rewards\n    function distributeLpRewards(uint _amount) external onlyTrading {\n        pool.increaseAccTokensPerLp(_amount);\n    }\n\n    function increaseNftRewards(\n        uint _nftId,\n        uint _amount\n    ) external onlyTrading {\n        nftLastSuccess[_nftId] = block.number;\n        nftRewards += _amount;\n    }\n\n    // Unlock next leverage\n    function setLeverageUnlocked(\n        address _trader,\n        uint _newLeverage\n    ) external onlyTrading {\n        traders[_trader].leverageUnlocked = _newLeverage;\n    }\n\n    // Manage dev & gov fees\n    function handleDevGovFees(\n        uint _pairIndex,\n        uint _leveragedPositionSize,\n        bool _WETH,\n        bool _fullFee\n    ) external onlyTrading returns (uint fee) {\n        fee =\n            (_leveragedPositionSize * priceAggregator.openFeeP(_pairIndex)) /\n            PRECISION /\n            100;\n        if (!_fullFee) {\n            fee /= 2;\n        }\n\n        if (_WETH) {\n            govFeesWETH += fee;\n            devFeesWETH += fee;\n        } else {\n            govFeesToken += fee;\n            devFeesToken += fee;\n        }\n\n        fee *= 2;\n    }\n\n    function claimFees() external onlyGov {\n        token.mint(dev, devFeesToken);\n        token.mint(gov, govFeesToken);\n\n        tokensMinted += devFeesToken + govFeesToken;\n\n        WETH.transfer(gov, govFeesWETH);\n        WETH.transfer(dev, devFeesWETH);\n\n        devFeesToken = 0;\n        govFeesToken = 0;\n        devFeesWETH = 0;\n        govFeesWETH = 0;\n    }\n\n    // Manage tokens\n    function handleTokens(\n        address _a,\n        uint _amount,\n        bool _mint\n    ) external onlyTrading {\n        if (_mint) {\n            token.mint(_a, _amount);\n            tokensMinted += _amount;\n        } else {\n            token.burn(_a, _amount);\n            tokensBurned += _amount;\n        }\n    }\n\n    function transferWETH(\n        address _from,\n        address _to,\n        uint _amount\n    ) external onlyTrading {\n        if (_from == address(this)) {\n            WETH.transfer(_to, _amount);\n        } else {\n            WETH.transferFrom(_from, _to, _amount);\n        }\n    }\n\n    function transferLinkToAggregator(\n        address _from,\n        uint _pairIndex,\n        uint _leveragedPosWETH\n    ) external onlyTrading {\n        linkErc677.transferFrom(\n            _from,\n            address(priceAggregator),\n            priceAggregator.linkFee(_pairIndex, _leveragedPosWETH)\n        );\n    }\n\n    // View utils functions\n    function firstEmptyTradeIndex(\n        address trader,\n        uint pairIndex\n    ) public view returns (uint index) {\n        for (uint i = 0; i < maxTradesPerPair; i++) {\n            if (openTrades[trader][pairIndex][i].leverage == 0) {\n                index = i;\n                break;\n            }\n        }\n    }\n\n    function firstEmptyOpenLimitIndex(\n        address trader,\n        uint pairIndex\n    ) public view returns (uint index) {\n        for (uint i = 0; i < maxTradesPerPair; i++) {\n            if (!hasOpenLimitOrder(trader, pairIndex, i)) {\n                index = i;\n                break;\n            }\n        }\n    }\n\n    function hasOpenLimitOrder(\n        address trader,\n        uint pairIndex,\n        uint index\n    ) public view returns (bool) {\n        if (openLimitOrders.length == 0) {\n            return false;\n        }\n        OpenLimitOrder storage o = openLimitOrders[\n            openLimitOrderIds[trader][pairIndex][index]\n        ];\n        return\n            o.trader == trader && o.pairIndex == pairIndex && o.index == index;\n    }\n\n    // Additional getters\n    function getReferral(address _trader) external view returns (address) {\n        return traders[_trader].referral;\n    }\n\n    function getLeverageUnlocked(address _trader) external view returns (uint) {\n        return traders[_trader].leverageUnlocked;\n    }\n\n    function pairTradersArray(\n        uint _pairIndex\n    ) external view returns (address[] memory) {\n        return pairTraders[_pairIndex];\n    }\n\n    function getPendingOrderIds(\n        address _trader\n    ) external view returns (uint[] memory) {\n        return pendingOrderIds[_trader];\n    }\n\n    function pendingOrderIdsCount(\n        address _trader\n    ) external view returns (uint) {\n        return pendingOrderIds[_trader].length;\n    }\n\n    function getOpenLimitOrder(\n        address _trader,\n        uint _pairIndex,\n        uint _index\n    ) external view returns (OpenLimitOrder memory) {\n        require(hasOpenLimitOrder(_trader, _pairIndex, _index));\n        return openLimitOrders[openLimitOrderIds[_trader][_pairIndex][_index]];\n    }\n\n    function getOpenLimitOrders()\n        external\n        view\n        returns (OpenLimitOrder[] memory)\n    {\n        return openLimitOrders;\n    }\n\n    function getSupportedTokens() external view returns (address[] memory) {\n        return supportedTokens;\n    }\n\n    function getSpreadReductionsArray() external view returns (uint[5] memory) {\n        return spreadReductionsP;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 125
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}