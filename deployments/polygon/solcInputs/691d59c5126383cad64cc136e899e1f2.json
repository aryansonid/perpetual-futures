{
  "language": "Solidity",
  "sources": {
    "contracts/Delegatable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nabstract contract Delegatable {\n    mapping(address => address) public delegations;\n    address private senderOverride;\n\n    function setDelegate(address delegate) external {\n        require(tx.origin == msg.sender, \"NO_CONTRACT\");\n\n        delegations[msg.sender] = delegate;\n    }\n\n    function removeDelegate() external {\n        delegations[msg.sender] = address(0);\n    }\n\n    function delegatedAction(\n        address trader,\n        bytes calldata call_data\n    ) external returns (bytes memory) {\n        require(delegations[trader] == msg.sender, \"DELEGATE_NOT_APPROVED\");\n\n        senderOverride = trader;\n        (bool success, bytes memory result) = address(this).delegatecall(\n            call_data\n        );\n        if (!success) {\n            // Next 5 lines from https://ethereum.stackexchange.com/a/83577 (return the original revert reason)\n            if (result.length < 68) revert();\n            assembly {\n                result := add(result, 0x04)\n            }\n            revert(abi.decode(result, (string)));\n        }\n\n        senderOverride = address(0);\n\n        return result;\n    }\n\n    function _msgSender() public view returns (address) {\n        if (senderOverride == address(0)) {\n            return msg.sender;\n        } else {\n            return senderOverride;\n        }\n    }\n}\n"
    },
    "contracts/interfaces/AggregatorInterfaceV1_4.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"./PairsStorageInterfaceV6.sol\";\nimport \"./ChainlinkFeedInterface.sol\";\nimport \"./StorageInterface.sol\";\n\ninterface AggregatorInterfaceV1_4 {\n    enum OrderType {\n        MARKET_OPEN,\n        MARKET_CLOSE,\n        LIMIT_OPEN,\n        LIMIT_CLOSE\n    }\n\n    function pairsStorage() external view returns (PairsStorageInterfaceV6);\n\n    function getPrice(uint, OrderType, uint, uint) external returns (uint);\n\n    function tokenPriceWETH() external returns (uint);\n\n    function linkFee(uint, uint) external view returns (uint);\n\n    function openFeeP(uint) external view returns (uint);\n\n    function linkPriceFeed() external view returns (ChainlinkFeedInterface);\n\n    function marketOrderfulfill(\n        uint256 orderId,\n        StorageInterface.PendingMarketOrder memory o\n    ) external;\n\n    function nftOrderfulfill(\n        uint256 orderId,\n        StorageInterface.PendingNftOrder memory o\n    ) external;\n}\n"
    },
    "contracts/interfaces/AggregatorInterfaceV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\nimport \"./StorageInterface.sol\";\n\ninterface AggregatorInterfaceV1 {\n    enum OrderType {\n        MARKET_OPEN,\n        MARKET_CLOSE,\n        LIMIT_OPEN,\n        LIMIT_CLOSE\n    }\n\n    function getPrice(uint, OrderType, uint) external returns (uint);\n\n    function tokenPriceWETH() external view returns (uint);\n\n    function pairMinOpenLimitSlippageP(uint) external view returns (uint);\n\n    function closeFeeP(uint) external view returns (uint);\n\n    function linkFee(uint, uint) external view returns (uint);\n\n    function openFeeP(uint) external view returns (uint);\n\n    function pairMinLeverage(uint) external view returns (uint);\n\n    function pairMaxLeverage(uint) external view returns (uint);\n\n    function pairsCount() external view returns (uint);\n\n    function tokenWETHReservesLp() external view returns (uint, uint);\n\n    function referralP(uint) external view returns (uint);\n\n    function nftLimitOrderFeeP(uint) external view returns (uint);\n\n    function marketOrderfulfill(\n        uint256 orderId,\n        StorageInterface.PendingMarketOrder memory o\n    ) external;\n\n    function nftOrderfulfill(\n        uint256 orderId,\n        StorageInterface.PendingNftOrder memory o\n    ) external;\n}\n"
    },
    "contracts/interfaces/BorrowingFeesInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\ninterface BorrowingFeesInterface {\n    // Structs\n    struct PairGroup {\n        uint16 groupIndex;\n        uint48 block;\n        uint64 initialAccFeeLong; // 1e10 (%)\n        uint64 initialAccFeeShort; // 1e10 (%)\n        uint64 prevGroupAccFeeLong; // 1e10 (%)\n        uint64 prevGroupAccFeeShort; // 1e10 (%)\n        uint64 pairAccFeeLong; // 1e10 (%)\n        uint64 pairAccFeeShort; // 1e10 (%)\n        uint64 _placeholder; // might be useful later\n    }\n    struct Pair {\n        PairGroup[] groups;\n        uint32 feePerBlock; // 1e10 (%)\n        uint64 accFeeLong; // 1e10 (%)\n        uint64 accFeeShort; // 1e10 (%)\n        uint48 accLastUpdatedBlock;\n        uint48 feeExponent;\n        uint lastAccBlockWeightedMarketCap; // 1e40\n    }\n    struct PairOi {\n        uint72 long; // 1e10 (DAI)\n        uint72 short; // 1e10 (DAI)\n        uint72 max; // 1e10 (DAI)\n        uint40 _placeholder; // might be useful later\n    }\n    struct Group {\n        uint112 oiLong; // 1e10\n        uint112 oiShort; // 1e10\n        uint32 feePerBlock; // 1e10 (%)\n        uint64 accFeeLong; // 1e10 (%)\n        uint64 accFeeShort; // 1e10 (%)\n        uint48 accLastUpdatedBlock;\n        uint80 maxOi; // 1e10\n        uint lastAccBlockWeightedMarketCap; // 1e40\n    }\n    struct InitialAccFees {\n        uint64 accPairFee; // 1e10 (%)\n        uint64 accGroupFee; // 1e10 (%)\n        uint48 block;\n        uint80 _placeholder; // might be useful later\n    }\n    struct PairParams {\n        uint16 groupIndex;\n        uint32 feePerBlock; // 1e10 (%)\n        uint48 feeExponent;\n        uint72 maxOi;\n    }\n    struct GroupParams {\n        uint32 feePerBlock; // 1e10 (%)\n        uint72 maxOi; // 1e10\n        uint48 feeExponent;\n    }\n    struct BorrowingFeeInput {\n        address trader;\n        uint pairIndex;\n        uint index;\n        bool long;\n        uint collateral; // 1e18 (DAI)\n        uint leverage;\n    }\n    struct LiqPriceInput {\n        address trader;\n        uint pairIndex;\n        uint index;\n        uint openPrice; // 1e10\n        bool long;\n        uint collateral; // 1e18 (DAI)\n        uint leverage;\n    }\n    struct PendingAccFeesInput {\n        uint64 accFeeLong; // 1e10 (%)\n        uint64 accFeeShort; // 1e10 (%)\n        uint oiLong; // 1e18\n        uint oiShort; // 1e18\n        uint32 feePerBlock; // 1e10\n        uint currentBlock;\n        uint accLastUpdatedBlock;\n        uint72 maxOi; // 1e10\n        uint48 feeExponent;\n    }\n\n    // Events\n    event PairParamsUpdated(\n        uint indexed pairIndex,\n        uint16 indexed groupIndex,\n        uint32 feePerBlock,\n        uint48 feeExponent,\n        uint72 maxOi\n    );\n    event PairGroupUpdated(\n        uint indexed pairIndex,\n        uint16 indexed prevGroupIndex,\n        uint16 indexed newGroupIndex\n    );\n    event GroupUpdated(\n        uint16 indexed groupIndex,\n        uint32 feePerBlock,\n        uint72 maxOi,\n        uint48 feeExponent\n    );\n    event TradeInitialAccFeesStored(\n        address indexed trader,\n        uint indexed pairIndex,\n        uint index,\n        uint64 initialPairAccFee,\n        uint64 initialGroupAccFee\n    );\n    event TradeActionHandled(\n        address indexed trader,\n        uint indexed pairIndex,\n        uint index,\n        bool open,\n        bool long,\n        uint positionSizeDai // 1e18\n    );\n    event PairAccFeesUpdated(\n        uint indexed pairIndex,\n        uint currentBlock,\n        uint64 accFeeLong,\n        uint64 accFeeShort\n    );\n    event GroupAccFeesUpdated(\n        uint16 indexed groupIndex,\n        uint currentBlock,\n        uint64 accFeeLong,\n        uint64 accFeeShort\n    );\n    event GroupOiUpdated(\n        uint16 indexed groupIndex,\n        bool indexed long,\n        bool indexed increase,\n        uint112 amount,\n        uint112 oiLong,\n        uint112 oiShort\n    );\n\n    // Functions\n    function getTradeLiquidationPrice(\n        LiqPriceInput calldata\n    ) external view returns (uint); // PRECISION\n\n    function getTradeBorrowingFee(\n        BorrowingFeeInput memory\n    ) external view returns (uint); // 1e18 (DAI)\n\n    function handleTradeAction(\n        address trader,\n        uint pairIndex,\n        uint index,\n        uint positionSizeDai, // 1e18 (collateral * leverage)\n        bool open,\n        bool long\n    ) external;\n\n    function withinMaxGroupOi(\n        uint pairIndex,\n        bool long,\n        uint positionSizeDai\n    ) external view returns (bool);\n\n    function getPairMaxOi(uint pairIndex) external view returns (uint);\n\n    function getTradePartialLiquidationPrice(\n        LiqPriceInput calldata input\n    ) external view returns (uint);\n}\n"
    },
    "contracts/interfaces/CallbacksInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"./StorageInterface.sol\";\n\ninterface CallbacksInterface {\n    struct AggregatorAnswer {\n        uint orderId;\n        uint price;\n        uint spreadP;\n        uint open;\n        uint high;\n        uint low;\n    }\n\n    // struct PendingMarketOrder {\n    //     Trade trade;\n    //     uint block;\n    //     uint wantedPrice; // PRECISION\n    //     uint slippageP; // PRECISION (%)\n    //     uint spreadReductionP;\n    //     uint tokenId; // index in supportedTokens\n    // }\n\n    // struct Trade {\n    //     address trader;\n    //     uint pairIndex;\n    //     uint index;\n    //     uint initialPosToken; // 1e18\n    //     uint positionSizeWETH; // 1e18\n    //     uint openPrice; // PRECISION\n    //     bool buy;\n    //     uint leverage;\n    //     uint tp; // PRECISION\n    //     uint sl; // PRECISION\n    // }\n\n    function openTradeMarketCallback(\n        AggregatorAnswer memory a,\n        StorageInterface.PendingMarketOrder memory o\n    ) external;\n\n    function closeTradeMarketCallback(\n        AggregatorAnswer memory a,\n        StorageInterface.PendingMarketOrder memory o\n    ) external;\n\n    function executeNftOpenOrderCallback(\n        AggregatorAnswer memory a,\n        StorageInterface.PendingNftOrder memory o\n    ) external;\n\n    function executeNftCloseOrderCallback(\n        AggregatorAnswer memory,\n        StorageInterface.PendingNftOrder memory o\n    ) external;\n\n    function getTradePnl(\n        address trader,\n        uint pairIndex,\n        uint index\n    ) external view returns (int256 pnl);\n}\n"
    },
    "contracts/interfaces/ChainlinkFeedInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\ninterface ChainlinkFeedInterface {\n    function latestRoundData()\n        external\n        view\n        returns (uint80, int, uint, uint, uint80);\n}\n"
    },
    "contracts/interfaces/IArbSys.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.21 <0.9.0;\n\n/**\n * @title Precompiled contract that exists in every Arbitrum chain at address(100), 0x0000000000000000000000000000000000000064. Exposes a variety of system-level functionality.\n */\ninterface IArbSys {\n    /**\n     * @notice Get internal version number identifying an ArbOS build\n     * @return version number as int\n     */\n    function arbOSVersion() external pure returns (uint);\n\n    function arbChainID() external view returns (uint);\n\n    /**\n     * @notice Get Arbitrum block number (distinct from L1 block number; Arbitrum genesis block has block number 0)\n     * @return block number as int\n     */\n    function arbBlockNumber() external view returns (uint);\n\n    /**\n     * @notice Send given amount of Eth to dest from sender.\n     * This is a convenience function, which is equivalent to calling sendTxToL1 with empty calldataForL1.\n     * @param destination recipient address on L1\n     * @return unique identifier for this L2-to-L1 transaction.\n     */\n    function withdrawEth(address destination) external payable returns (uint);\n\n    /**\n     * @notice Send a transaction to L1\n     * @param destination recipient address on L1\n     * @param calldataForL1 (optional) calldata for L1 contract call\n     * @return a unique identifier for this L2-to-L1 transaction.\n     */\n    function sendTxToL1(address destination, bytes calldata calldataForL1) external payable returns (uint);\n\n    /**\n     * @notice get the number of transactions issued by the given external account or the account sequence number of the given contract\n     * @param account target account\n     * @return the number of transactions issued by the given external account or the account sequence number of the given contract\n     */\n    function getTransactionCount(address account) external view returns (uint256);\n\n    /**\n     * @notice get the value of target L2 storage slot\n     * This function is only callable from address 0 to prevent contracts from being able to call it\n     * @param account target account\n     * @param index target index of storage slot\n     * @return stotage value for the given account at the given index\n     */\n    function getStorageAt(address account, uint256 index) external view returns (uint256);\n\n    /**\n     * @notice check if current call is coming from l1\n     * @return true if the caller of this was called directly from L1\n     */\n    function isTopLevelCall() external view returns (bool);\n\n    /**\n     * @notice check if the caller (of this caller of this) is an aliased L1 contract address\n     * @return true iff the caller's address is an alias for an L1 contract address\n     */\n    function wasMyCallersAddressAliased() external view returns (bool);\n\n    /**\n     * @notice return the address of the caller (of this caller of this), without applying L1 contract address aliasing\n     * @return address of the caller's caller, without applying L1 contract address aliasing\n     */\n    function myCallersAddressWithoutAliasing() external view returns (address);\n\n    /**\n     * @notice map L1 sender contract address to its L2 alias\n     * @param sender sender address\n     * @param dest destination address\n     * @return aliased sender address\n     */\n    function mapL1SenderContractAddressToL2Alias(address sender, address dest) external pure returns (address);\n\n    /**\n     * @notice get the caller's amount of available storage gas\n     * @return amount of storage gas available to the caller\n     */\n    function getStorageGasAvailable() external view returns (uint);\n\n    event L2ToL1Transaction(\n        address caller,\n        address indexed destination,\n        uint indexed uniqueId,\n        uint indexed batchNumber,\n        uint indexInBatch,\n        uint arbBlockNum,\n        uint ethBlockNum,\n        uint timestamp,\n        uint callvalue,\n        bytes data\n    );\n}"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\ninterface IOracle {\n    function getPrice(\n        uint256 tokenIndex\n    ) external view returns (uint256 price, uint256 lastupdateTime);\n\n    function getFundingFee(\n        uint256 tokenIndex\n    ) external view returns (uint256 fee);\n}\n"
    },
    "contracts/interfaces/IToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\ninterface IToken {\n    function manager() external view returns (address);\n\n    function admin() external view returns (address);\n\n    function currentEpoch() external view returns (uint);\n\n    function currentEpochStart() external view returns (uint);\n\n    function currentEpochPositiveOpenPnl() external view returns (uint);\n\n    function updateAccPnlPerTokenUsed(\n        uint prevPositiveOpenPnl,\n        uint newPositiveOpenPnl\n    ) external returns (uint);\n\n    struct LockedDeposit {\n        address owner;\n        uint shares; // 1e18\n        uint assetsDeposited; // 1e18\n        uint assetsDiscount; // 1e18\n        uint atTimestamp; // timestamp\n        uint lockDuration; // timestamp\n    }\n\n    function getLockedDeposit(\n        uint depositId\n    ) external view returns (LockedDeposit memory);\n\n    function sendAssets(uint assets, address receiver) external;\n\n    function receiveAssets(uint assets, address user) external;\n\n    function distributeReward(uint assets) external;\n\n    function currentBalanceWETH() external view returns (uint);\n\n    function tvl() external view returns (uint);\n\n    function marketCap() external view returns (uint);\n\n    function getPendingAccBlockWeightedMarketCap(\n        uint currentBlock\n    ) external view returns (uint);\n}\n"
    },
    "contracts/interfaces/NftInterfaceV5.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\ninterface NftInterfaceV5 {\n    function balanceOf(address) external view returns (uint);\n\n    function ownerOf(uint) external view returns (address);\n\n    function transferFrom(address, address, uint) external;\n\n    function tokenOfOwnerByIndex(address, uint) external view returns (uint);\n}\n"
    },
    "contracts/interfaces/NFTRewardInterfaceV6_3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"./StorageInterface.sol\";\n\ninterface NftRewardsInterfaceV6_3_1 {\n    struct TriggeredLimitId {\n        address trader;\n        uint pairIndex;\n        uint index;\n        StorageInterface.LimitOrder order;\n    }\n    enum OpenLimitOrderType {\n        LEGACY,\n        REVERSAL,\n        MOMENTUM\n    }\n\n    function storeFirstToTrigger(\n        TriggeredLimitId calldata,\n        address,\n        uint\n    ) external;\n\n    function storeTriggerSameBlock(TriggeredLimitId calldata, address) external;\n\n    function unregisterTrigger(TriggeredLimitId calldata) external;\n\n    function distributeNftReward(\n        TriggeredLimitId calldata,\n        uint,\n        uint\n    ) external;\n\n    function openLimitOrderTypes(\n        address,\n        uint,\n        uint\n    ) external view returns (OpenLimitOrderType);\n\n    function setOpenLimitOrderType(\n        address,\n        uint,\n        uint,\n        OpenLimitOrderType\n    ) external;\n\n    function triggered(TriggeredLimitId calldata) external view returns (bool);\n\n    function timedOut(TriggeredLimitId calldata) external view returns (bool);\n\n    function botInUse(bytes32) external view returns (bool);\n\n    function getNftBotHashes(\n        uint,\n        address,\n        uint,\n        address,\n        uint,\n        uint\n    ) external pure returns (bytes32, bytes32);\n\n    function setNftBotInUse(bytes32, bytes32) external;\n\n    function nftBotInUse(bytes32, bytes32) external view returns (bool);\n\n    function linkToTokenRewards(uint, uint) external view returns (uint);\n}\n"
    },
    "contracts/interfaces/PairInfosInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\ninterface PairInfosInterface {\n    // Trade initial acc fees\n    struct TradeInitialAccFees {\n        uint rollover; // 1e18 (DAI)\n        int funding; // 1e18 (DAI)\n        bool openedAfterUpdate;\n    }\n\n    function tradeInitialAccFees(\n        address,\n        uint,\n        uint\n    ) external view returns (TradeInitialAccFees memory);\n\n    function maxNegativePnlOnOpenP() external view returns (uint); // PRECISION (%)\n\n    function storeTradeInitialAccFees(\n        address trader,\n        uint pairIndex,\n        uint index,\n        bool long\n    ) external;\n\n    function getTradePriceImpact(\n        uint openPrice, // PRECISION\n        uint pairIndex,\n        bool long,\n        uint openInterest // 1e18 (DAI)\n    )\n        external\n        view\n        returns (\n            uint priceImpactP, // PRECISION (%)\n            uint priceAfterImpact // PRECISION\n        );\n\n    function getTradeRolloverFee(\n        address trader,\n        uint pairIndex,\n        uint index,\n        uint collateral // 1e18 (DAI)\n    ) external view returns (uint);\n\n    function getTradeFundingFee(\n        address trader,\n        uint pairIndex,\n        uint index,\n        bool long,\n        uint collateral, // 1e18 (DAI)\n        uint leverage\n    )\n        external\n        view\n        returns (\n            int // 1e18 (DAI) | Positive => Fee, Negative => Reward\n        );\n\n    function getTradeLiquidationPricePure(\n        uint openPrice, // PRECISION\n        bool long,\n        uint collateral, // 1e18 (DAI)\n        uint leverage,\n        uint rolloverFee, // 1e18 (DAI)\n        int fundingFee // 1e18 (DAI)\n    ) external pure returns (uint);\n\n    function getTradeLiquidationPrice(\n        address trader,\n        uint pairIndex,\n        uint index,\n        uint openPrice, // PRECISION\n        bool long,\n        uint collateral, // 1e18 (DAI)\n        uint leverage\n    ) external view returns (uint); // PRECISION\n\n    function getTradeValue(\n        address trader,\n        uint pairIndex,\n        uint index,\n        bool long,\n        uint collateral, // 1e18 (DAI)\n        uint leverage,\n        int percentProfit, // PRECISION (%)\n        uint closingFee // 1e18 (DAI)\n    ) external returns (uint); // 1e18 (DAI)\n\n    function manager() external view returns (address);\n\n    function getTradeValuePure(\n        uint collateral, // 1e18 (WETH)\n        int percentProfit, // PRECISION (%)\n        uint rolloverFee, // 1e18 (WETH)\n        int fundingFee, // 1e18 (WETH)\n        uint closingFee // 1e18 (WETH)\n    ) external view returns (uint);\n\n    function getTradePartialLiquidationPrice(\n        uint openPrice, // PRECISION\n        bool long,\n        uint collateral, // 1e18 (DAI)\n        uint leverage,\n        uint rolloverFee, // 1e18 (DAI)\n        int fundingFee // 1e18 (DAI)\n    ) external pure returns (uint);\n}\n"
    },
    "contracts/interfaces/PairsStorageInterfaceV6.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\ninterface PairsStorageInterfaceV6 {\n    enum FeedCalculation {\n        DEFAULT,\n        INVERT,\n        COMBINE\n    } // FEED 1, 1 / (FEED 1), (FEED 1)/(FEED 2)\n    struct Feed {\n        address feed1;\n        address feed2;\n        FeedCalculation feedCalculation;\n        uint maxDeviationP;\n    } // PRECISION (%)\n\n    function incrementCurrentOrderId() external returns (uint);\n\n    function updateGroupCollateral(uint, uint, bool, bool) external;\n\n    function pairJob(\n        uint\n    ) external returns (string memory, string memory, bytes32, uint);\n\n    function pairFeed(uint) external view returns (Feed memory);\n\n    function pairSpreadP(uint) external view returns (uint);\n\n    function pairMinLeverage(uint) external view returns (uint);\n\n    function pairMaxLeverage(uint) external view returns (uint);\n\n    function groupMaxCollateral(uint) external view returns (uint);\n\n    function groupCollateral(uint, bool) external view returns (uint);\n\n    function guaranteedSlEnabled(uint) external view returns (bool);\n\n    function pairOpenFeeP(uint) external view returns (uint);\n\n    function pairCloseFeeP(uint) external view returns (uint);\n\n    function pairOracleFeeP(uint) external view returns (uint);\n\n    function pairNftLimitOrderFeeP(uint) external view returns (uint);\n\n    function pairReferralFeeP(uint) external view returns (uint);\n\n    function pairMinLevPosWETH(uint) external view returns (uint);\n\n    function pairsCount() external view returns (uint);\n}\n"
    },
    "contracts/interfaces/PausableInterfaceV5.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {StorageInterface} from \"./StorageInterface.sol\";\n\ninterface PausableInterfaceV5 {\n    function isPaused() external view returns (bool);\n\n    function isTradeParLiquidatablePure(\n        StorageInterface.Trade memory t\n    ) external view returns (bool, bool);\n\n    function isTradeLiquidatablePure(\n        StorageInterface.Trade memory t\n    ) external view returns (bool, bool);\n\n    function executeNftOrders(\n        uint[100] memory _orderTypes,\n        address[100] memory traders,\n        uint[100] memory pairIndexs,\n        uint[100] memory index\n    ) external;\n}\n"
    },
    "contracts/interfaces/ReferralsInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\ninterface ReferralsInterface {\n    function registerPotentialReferrer(\n        address trader,\n        address referral\n    ) external;\n\n    function distributePotentialReward(\n        address trader,\n        uint volumeWETH,\n        uint pairOpenFeeP,\n        uint tokenPriceWETH\n    ) external returns (uint);\n\n    function getPercentOfOpenFeeP(address trader) external view returns (uint);\n\n    function getTraderReferrer(\n        address trader\n    ) external view returns (address referrer);\n}\n"
    },
    "contracts/interfaces/StorageInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"./TokenInterface.sol\";\nimport \"./NftInterfaceV5.sol\";\nimport \"./IToken.sol\";\nimport \"./AggregatorInterfaceV1.sol\";\nimport \"./IOracle.sol\";\nimport \"./PausableInterfaceV5.sol\";\n\ninterface StorageInterface {\n    enum LimitOrder {\n        TP,\n        SL,\n        LIQ,\n        OPEN,\n        PAR_LIQ\n    }\n    struct Trade {\n        address trader;\n        uint pairIndex;\n        uint index;\n        uint initialPosToken; // 1e18\n        uint positionSizeWETH; // 1e18\n        uint openPrice; // PRECISION\n        bool buy;\n        uint leverage;\n        uint tp; // PRECISION\n        uint sl; // PRECISION\n    }\n    struct TradeInfo {\n        uint tokenId;\n        uint tokenPriceWETH; // PRECISION\n        uint openInterestWETH; // 1e18\n        uint tpLastUpdated;\n        uint slLastUpdated;\n        bool beingMarketClosed;\n    }\n    struct OpenLimitOrder {\n        address trader;\n        uint pairIndex;\n        uint index;\n        uint positionSize; // 1e18 (WETH or GFARM2)\n        uint spreadReductionP;\n        bool buy;\n        uint leverage;\n        uint tp; // PRECISION (%)\n        uint sl; // PRECISION (%)\n        uint minPrice; // PRECISION\n        uint maxPrice; // PRECISION\n        uint block;\n        uint tokenId; // index in supportedTokens\n    }\n    struct PendingMarketOrder {\n        Trade trade;\n        uint block;\n        uint wantedPrice; // PRECISION\n        uint slippageP; // PRECISION (%)\n        uint spreadReductionP;\n        uint tokenId; // index in supportedTokens\n    }\n    struct PendingNftOrder {\n        address nftHolder;\n        uint nftId;\n        address trader;\n        uint pairIndex;\n        uint index;\n        LimitOrder orderType;\n    }\n\n    event OpenningInterestUpated(\n        uint256 indexed pairIndex,\n        uint256 indexed openingInterestShort,\n        uint256 indexed openingInterestLong\n    );\n\n    event TradeOpen(Trade indexed t);\n\n    event TradeClose(Trade indexed t);\n\n    function PRECISION() external pure returns (uint);\n\n    function gov() external view returns (address);\n\n    function dev() external view returns (address);\n\n    function WETH() external view returns (TokenInterface);\n\n    function token() external view returns (TokenInterface);\n\n    function linkErc677() external view returns (TokenInterface);\n\n    function priceAggregator() external view returns (AggregatorInterfaceV1);\n\n    function vault() external view returns (address);\n\n    function trading() external view returns (PausableInterfaceV5);\n\n    function callbacks() external view returns (PausableInterfaceV5);\n\n    function handleTokens(address, uint, bool) external;\n\n    function transferWETH(address, address, uint) external;\n\n    function transferLinkToAggregator(address, uint, uint) external;\n\n    function unregisterTrade(address, uint, uint) external;\n\n    function unregisterPendingMarketOrder(uint, bool) external;\n\n    function unregisterOpenLimitOrder(address, uint, uint) external;\n\n    function hasOpenLimitOrder(\n        address,\n        uint,\n        uint\n    ) external view returns (bool);\n\n    function storePendingMarketOrder(\n        PendingMarketOrder memory,\n        uint,\n        bool\n    ) external;\n\n    function getOpenTrades(\n        address,\n        uint,\n        uint\n    ) external view returns (Trade memory);\n\n    function getOpenTradesInfo(\n        address,\n        uint,\n        uint\n    ) external view returns (TradeInfo memory);\n\n    function updateSl(address, uint, uint, uint) external;\n\n    function updateTp(address, uint, uint, uint) external;\n\n    function getOpenLimitOrder(\n        address,\n        uint,\n        uint\n    ) external view returns (OpenLimitOrder memory);\n\n    function spreadReductionsP(uint) external view returns (uint);\n\n    function storeOpenLimitOrder(OpenLimitOrder memory) external;\n\n    function getPendingMarketOrder(\n        uint\n    ) external view returns (PendingMarketOrder memory);\n\n    function storePendingNftOrder(PendingNftOrder memory, uint) external;\n\n    function updateOpenLimitOrder(OpenLimitOrder calldata) external;\n\n    function firstEmptyTradeIndex(address, uint) external view returns (uint);\n\n    function firstEmptyOpenLimitIndex(\n        address,\n        uint\n    ) external view returns (uint);\n\n    function increaseNftRewards(uint, uint) external;\n\n    function nftSuccessTimelock() external view returns (uint);\n\n    function getPendingNftOrder(\n        uint\n    ) external view returns (PendingNftOrder memory);\n\n    function updateTrade(Trade memory) external;\n\n    function nftLastSuccess(uint) external view returns (uint);\n\n    function unregisterPendingNftOrder(uint) external;\n\n    function handleDevGovFees(uint, uint, bool, bool) external returns (uint);\n\n    function distributeLpRewards(uint) external;\n\n    function storeTrade(Trade memory, TradeInfo memory) external;\n\n    function openLimitOrdersCount(address, uint) external view returns (uint);\n\n    function openTradesCount(address, uint) external view returns (uint);\n\n    function pendingMarketOpenCount(address, uint) external view returns (uint);\n\n    function pendingMarketCloseCount(\n        address,\n        uint\n    ) external view returns (uint);\n\n    function maxTradesPerPair() external view returns (uint);\n\n    function pendingOrderIdsCount(address) external view returns (uint);\n\n    function maxPendingMarketOrders() external view returns (uint);\n\n    function openInterestWETH(uint, uint) external view returns (uint);\n\n    function getPendingOrderIds(address) external view returns (uint[] memory);\n\n    function nfts(uint) external view returns (NftInterfaceV5);\n\n    // function fakeBlockNumber() external view returns (uint); // Testing\n\n    function getGov() external view returns (address); // checking\n\n    function mintWETH(address _to, uint _amount) external;\n\n    function oracle() external view returns (IOracle);\n\n    function getLiquidatableTrades()\n        external\n        view\n        returns (\n            uint[100] memory _orderTypes,\n            address[100] memory traders,\n            uint[100] memory pairIndexs,\n            uint[100] memory indexs\n        );\n}\n"
    },
    "contracts/interfaces/TokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\ninterface TokenInterface {\n    function burn(address, uint256) external;\n\n    function mint(address, uint256) external;\n\n    function transfer(address, uint256) external returns (bool);\n\n    function transferFrom(address, address, uint256) external returns (bool);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function hasRole(bytes32, address) external view returns (bool);\n\n    function approve(address, uint256) external returns (bool);\n\n    function allowance(address, address) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/TradingCallbacksInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\ninterface TradingCallbacksInterface {\n    enum TradeType {\n        MARKET,\n        LIMIT\n    }\n    struct SimplifiedTradeId {\n        address trader;\n        uint pairIndex;\n        uint index;\n        TradeType tradeType;\n    }\n    struct LastUpdated {\n        uint32 tp;\n        uint32 sl;\n        uint32 limit;\n        uint32 created;\n    }\n    struct TradeData {\n        uint40 maxSlippageP; // 1e10 (%)\n        uint216 _placeholder; // for potential future data\n    }\n\n    function tradeLastUpdated(\n        address,\n        uint,\n        uint,\n        TradeType\n    ) external view returns (LastUpdated memory);\n\n    function setTradeLastUpdated(\n        SimplifiedTradeId calldata,\n        LastUpdated memory\n    ) external;\n\n    function setTradeData(\n        SimplifiedTradeId calldata,\n        TradeData memory\n    ) external;\n\n    function canExecuteTimeout() external view returns (uint);\n\n    function pairMaxLeverage(uint) external view returns (uint);\n}\n"
    },
    "contracts/libraries/ChainUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"../interfaces/IArbSys.sol\";\n\nlibrary ChainUtils {\n    uint256 public constant ARBITRUM_MAINNET = 42161;\n    uint256 public constant ARBITRUM_GOERLI = 421613;\n    IArbSys public constant ARB_SYS = IArbSys(address(100));\n\n    function getBlockNumber() internal view returns (uint) {\n        if (\n            block.chainid == ARBITRUM_MAINNET ||\n            block.chainid == ARBITRUM_GOERLI\n        ) {\n            return ARB_SYS.arbBlockNumber();\n        }\n\n        return block.number;\n    }\n\n    function getUint48BlockNumber(\n        uint blockNumber\n    ) internal pure returns (uint48) {\n        require(blockNumber <= type(uint48).max, \"OVERFLOW\");\n        return uint48(blockNumber);\n    }\n}\n"
    },
    "contracts/libraries/PackingUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nlibrary PackingUtils {\n    function pack(\n        uint256[] memory values,\n        uint256[] memory bitLengths\n    ) external pure returns (uint256 packed) {\n        require(\n            values.length == bitLengths.length,\n            \"Mismatch in the lengths of values and bitLengths arrays\"\n        );\n\n        uint256 currentShift;\n\n        for (uint256 i; i < values.length; i++) {\n            require(\n                currentShift + bitLengths[i] <= 256,\n                \"Packed value exceeds 256 bits\"\n            );\n\n            uint256 maxValue = (1 << bitLengths[i]) - 1;\n            require(\n                values[i] <= maxValue,\n                \"Value too large for specified bit length\"\n            );\n\n            uint256 maskedValue = values[i] & maxValue;\n            packed |= maskedValue << currentShift;\n            currentShift += bitLengths[i];\n        }\n    }\n\n    function unpack(\n        uint256 packed,\n        uint256[] memory bitLengths\n    ) external pure returns (uint256[] memory values) {\n        values = new uint256[](bitLengths.length);\n\n        uint256 currentShift;\n        for (uint256 i; i < bitLengths.length; i++) {\n            require(\n                currentShift + bitLengths[i] <= 256,\n                \"Unpacked value exceeds 256 bits\"\n            );\n\n            uint256 maxValue = (1 << bitLengths[i]) - 1;\n            uint256 mask = maxValue << currentShift;\n            values[i] = (packed & mask) >> currentShift;\n\n            currentShift += bitLengths[i];\n        }\n    }\n\n    function unpack256To64(\n        uint256 packed\n    ) external pure returns (uint64 a, uint64 b, uint64 c, uint64 d) {\n        a = uint64(packed);\n        b = uint64(packed >> 64);\n        c = uint64(packed >> 128);\n        d = uint64(packed >> 192);\n    }\n\n    // Function-specific unpacking utils\n    function unpackExecuteNftOrder(\n        uint256 packed\n    )\n        external\n        pure\n        returns (\n            uint256 a,\n            address b,\n            uint256 c,\n            uint256 d,\n            uint256 e,\n            uint256 f\n        )\n    {\n        a = packed & 0xFF; // 8 bits\n        b = address(uint160(packed >> 8)); // 160 bits\n        c = (packed >> 168) & 0xFFFF; // 16 bits\n        d = (packed >> 184) & 0xFFFF; // 16 bits\n        e = (packed >> 200) & 0xFFFF; // 16 bits\n        f = (packed >> 216) & 0xFFFF; // 16 bits\n    }\n}\n"
    },
    "contracts/libraries/TradeUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"../interfaces/StorageInterface.sol\";\nimport \"../interfaces/TradingCallbacksInterface.sol\";\n\nlibrary TradeUtils {\n    function _getTradeLastUpdated(\n        address _callbacks,\n        address trader,\n        uint pairIndex,\n        uint index,\n        TradingCallbacksInterface.TradeType _type\n    )\n        internal\n        view\n        returns (\n            TradingCallbacksInterface,\n            TradingCallbacksInterface.LastUpdated memory,\n            TradingCallbacksInterface.SimplifiedTradeId memory\n        )\n    {\n        TradingCallbacksInterface callbacks = TradingCallbacksInterface(\n            _callbacks\n        );\n        TradingCallbacksInterface.LastUpdated memory l = callbacks\n            .tradeLastUpdated(trader, pairIndex, index, _type);\n\n        return (\n            callbacks,\n            l,\n            TradingCallbacksInterface.SimplifiedTradeId(\n                trader,\n                pairIndex,\n                index,\n                _type\n            )\n        );\n    }\n\n    function setTradeLastUpdated(\n        address _callbacks,\n        address trader,\n        uint pairIndex,\n        uint index,\n        TradingCallbacksInterface.TradeType _type,\n        uint blockNumber\n    ) external {\n        uint32 b = uint32(blockNumber);\n        TradingCallbacksInterface callbacks = TradingCallbacksInterface(\n            _callbacks\n        );\n        callbacks.setTradeLastUpdated(\n            TradingCallbacksInterface.SimplifiedTradeId(\n                trader,\n                pairIndex,\n                index,\n                _type\n            ),\n            TradingCallbacksInterface.LastUpdated(b, b, b, b)\n        );\n    }\n\n    function setSlLastUpdated(\n        address _callbacks,\n        address trader,\n        uint pairIndex,\n        uint index,\n        TradingCallbacksInterface.TradeType _type,\n        uint blockNumber\n    ) external {\n        (\n            TradingCallbacksInterface callbacks,\n            TradingCallbacksInterface.LastUpdated memory l,\n            TradingCallbacksInterface.SimplifiedTradeId memory id\n        ) = _getTradeLastUpdated(_callbacks, trader, pairIndex, index, _type);\n\n        l.sl = uint32(blockNumber);\n        callbacks.setTradeLastUpdated(id, l);\n    }\n\n    function setTpLastUpdated(\n        address _callbacks,\n        address trader,\n        uint pairIndex,\n        uint index,\n        TradingCallbacksInterface.TradeType _type,\n        uint blockNumber\n    ) external {\n        (\n            TradingCallbacksInterface callbacks,\n            TradingCallbacksInterface.LastUpdated memory l,\n            TradingCallbacksInterface.SimplifiedTradeId memory id\n        ) = _getTradeLastUpdated(_callbacks, trader, pairIndex, index, _type);\n\n        l.tp = uint32(blockNumber);\n        callbacks.setTradeLastUpdated(id, l);\n    }\n\n    function isTpInTimeout(\n        address _callbacks,\n        TradingCallbacksInterface.SimplifiedTradeId memory id,\n        uint currentBlock\n    ) external view returns (bool) {\n        (\n            TradingCallbacksInterface callbacks,\n            TradingCallbacksInterface.LastUpdated memory l,\n\n        ) = _getTradeLastUpdated(\n                _callbacks,\n                id.trader,\n                id.pairIndex,\n                id.index,\n                id.tradeType\n            );\n\n        return currentBlock < uint256(l.tp) + callbacks.canExecuteTimeout();\n    }\n\n    function isSlInTimeout(\n        address _callbacks,\n        TradingCallbacksInterface.SimplifiedTradeId memory id,\n        uint currentBlock\n    ) external view returns (bool) {\n        (\n            TradingCallbacksInterface callbacks,\n            TradingCallbacksInterface.LastUpdated memory l,\n\n        ) = _getTradeLastUpdated(\n                _callbacks,\n                id.trader,\n                id.pairIndex,\n                id.index,\n                id.tradeType\n            );\n\n        return currentBlock < uint256(l.sl) + callbacks.canExecuteTimeout();\n    }\n\n    function isLimitInTimeout(\n        address _callbacks,\n        TradingCallbacksInterface.SimplifiedTradeId memory id,\n        uint currentBlock\n    ) external view returns (bool) {\n        (\n            TradingCallbacksInterface callbacks,\n            TradingCallbacksInterface.LastUpdated memory l,\n\n        ) = _getTradeLastUpdated(\n                _callbacks,\n                id.trader,\n                id.pairIndex,\n                id.index,\n                id.tradeType\n            );\n\n        return currentBlock < uint256(l.limit) + callbacks.canExecuteTimeout();\n    }\n\n    function setTradeData(\n        address _callbacks,\n        address trader,\n        uint pairIndex,\n        uint index,\n        TradingCallbacksInterface.TradeType _type,\n        uint maxSlippageP\n    ) external {\n        require(maxSlippageP <= type(uint40).max, \"OVERFLOW\");\n        TradingCallbacksInterface callbacks = TradingCallbacksInterface(\n            _callbacks\n        );\n        callbacks.setTradeData(\n            TradingCallbacksInterface.SimplifiedTradeId(\n                trader,\n                pairIndex,\n                index,\n                _type\n            ),\n            TradingCallbacksInterface.TradeData(uint40(maxSlippageP), 0)\n        );\n    }\n}\n"
    },
    "contracts/Trading.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"./interfaces/StorageInterface.sol\";\nimport \"./interfaces/PairInfosInterface.sol\";\nimport \"./interfaces/ReferralsInterface.sol\";\nimport \"./interfaces/BorrowingFeesInterface.sol\";\nimport \"./Delegatable.sol\";\nimport \"./libraries/ChainUtils.sol\";\nimport \"./libraries/TradeUtils.sol\";\nimport \"./libraries/PackingUtils.sol\";\nimport \"./interfaces/NFTRewardInterfaceV6_3.sol\";\nimport \"./interfaces/CallbacksInterface.sol\";\nimport \"./interfaces/PairsStorageInterfaceV6.sol\";\nimport \"./interfaces/AggregatorInterfaceV1_4.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Trading is Delegatable {\n    using TradeUtils for address;\n    using PackingUtils for uint256;\n\n    // Contracts (constant)\n    StorageInterface public immutable storageT;\n    NftRewardsInterfaceV6_3_1 public immutable nftRewards;\n    PairInfosInterface public immutable pairInfos;\n    ReferralsInterface public immutable referrals;\n    BorrowingFeesInterface public immutable borrowingFees;\n    CallbacksInterface public immutable callbacks;\n\n    // Params (constant)\n    uint constant PRECISION = 1e10;\n    uint constant MAX_SL_P = 75; // -75% PNL\n\n    // Params (adjustable)\n    uint public maxPosWETH; // 1e18 (eg. 75000 * 1e18)\n    uint public marketOrdersTimeout; // block (eg. 30)\n    int public minLeveragedPosWETH = 10e18; //100 weth\n\n    // State\n    bool public isPaused; // Prevent opening new trades\n    bool public isDone; // Prevent any interaction with the contract\n\n    // Events\n    event Done(bool done);\n    event Paused(bool paused);\n\n    event NumberUpdated(string name, uint value);\n\n    event MarketOrderInitiated(\n        uint indexed orderId,\n        address indexed trader,\n        uint indexed pairIndex,\n        bool open\n    );\n\n    event OpenLimitPlaced(\n        address indexed trader,\n        uint indexed pairIndex,\n        uint index\n    );\n    event OpenLimitUpdated(\n        address indexed trader,\n        uint indexed pairIndex,\n        uint index,\n        uint newPrice,\n        uint newTp,\n        uint newSl,\n        uint maxSlippageP\n    );\n    event OpenLimitCanceled(\n        address indexed trader,\n        uint indexed pairIndex,\n        uint index\n    );\n\n    event TpUpdated(\n        address indexed trader,\n        uint indexed pairIndex,\n        uint index,\n        uint newTp\n    );\n    event SlUpdated(\n        address indexed trader,\n        uint indexed pairIndex,\n        uint index,\n        uint newSl\n    );\n\n    event NftOrderInitiated(\n        uint orderId,\n        address indexed nftHolder,\n        address indexed trader,\n        uint indexed pairIndex\n    );\n    event NftOrderSameBlock(\n        address indexed nftHolder,\n        address indexed trader,\n        uint indexed pairIndex\n    );\n\n    event ChainlinkCallbackTimeout(\n        uint indexed orderId,\n        StorageInterface.PendingMarketOrder order\n    );\n    event CouldNotCloseTrade(\n        address indexed trader,\n        uint indexed pairIndex,\n        uint index\n    );\n\n    constructor(\n        StorageInterface _storageT,\n        NftRewardsInterfaceV6_3_1 _nftRewards,\n        PairInfosInterface _pairInfos,\n        ReferralsInterface _referrals,\n        BorrowingFeesInterface _borrowingFees,\n        CallbacksInterface _callbacks,\n        uint _maxPosWETH,\n        uint _marketOrdersTimeout\n    ) {\n        require(\n            address(_storageT) != address(0) &&\n                address(_nftRewards) != address(0) &&\n                address(_pairInfos) != address(0) &&\n                address(_referrals) != address(0) &&\n                address(_borrowingFees) != address(0) &&\n                address(_callbacks) != address(0) &&\n                _maxPosWETH > 0 &&\n                _marketOrdersTimeout > 0,\n            \"WRONG_PARAMS\"\n        );\n\n        storageT = _storageT;\n        nftRewards = _nftRewards;\n        pairInfos = _pairInfos;\n        referrals = _referrals;\n        borrowingFees = _borrowingFees;\n\n        maxPosWETH = _maxPosWETH;\n        marketOrdersTimeout = _marketOrdersTimeout;\n        callbacks = _callbacks;\n    }\n\n    // Modifiers\n    modifier onlyGov() {\n        isGov();\n        _;\n    }\n    modifier notContract() {\n        isNotContract();\n        _;\n    }\n    modifier notDone() {\n        isNotDone();\n        _;\n    }\n\n    // Saving code size by calling these functions inside modifiers\n    function isGov() private view {\n        require(msg.sender == storageT.gov(), \"GOV_ONLY\");\n    }\n\n    function isNotContract() private view {\n        require(tx.origin == msg.sender);\n    }\n\n    function isNotDone() private view {\n        require(!isDone, \"DONE\");\n    }\n\n    // Manage params\n    function setMaxPosWETH(uint value) external onlyGov {\n        require(value > 0, \"VALUE_0\");\n        maxPosWETH = value;\n        emit NumberUpdated(\"maxPosWETH\", value);\n    }\n\n    function setMarketOrdersTimeout(uint value) external onlyGov {\n        require(value > 0, \"VALUE_0\");\n        marketOrdersTimeout = value;\n        emit NumberUpdated(\"marketOrdersTimeout\", value);\n    }\n\n    // Manage state\n    function pause() external onlyGov {\n        isPaused = !isPaused;\n        emit Paused(isPaused);\n    }\n\n    function done() external onlyGov {\n        isDone = !isDone;\n        emit Done(isDone);\n    }\n\n    // Open new trade (MARKET/LIMIT)\n    function openTrade(\n        StorageInterface.Trade memory t,\n        NftRewardsInterfaceV6_3_1.OpenLimitOrderType orderType, // LEGACY => market\n        uint spreadReductionId,\n        uint slippageP // 1e10 (%)\n    )\n        external\n        // address referrer\n        notContract\n        notDone\n    {\n        require(!isPaused, \"PAUSED\");\n        require(t.openPrice * slippageP < type(uint256).max, \"OVERFLOW\");\n        require(t.openPrice > 0, \"PRICE_ZERO\");\n\n        AggregatorInterfaceV1_4 aggregator = AggregatorInterfaceV1_4(\n            address(storageT.priceAggregator())\n        );\n        PairsStorageInterfaceV6 pairsStored = aggregator.pairsStorage();\n\n        address sender = _msgSender();\n\n        require(\n            storageT.openTradesCount(sender, t.pairIndex) +\n                storageT.pendingMarketOpenCount(sender, t.pairIndex) +\n                storageT.openLimitOrdersCount(sender, t.pairIndex) <\n                storageT.maxTradesPerPair(),\n            \"MAX_TRADES_PER_PAIR\"\n        );\n\n        require(\n            storageT.pendingOrderIdsCount(sender) <\n                storageT.maxPendingMarketOrders(),\n            \"MAX_PENDING_ORDERS\"\n        );\n        require(t.positionSizeWETH <= maxPosWETH, \"ABOVE_MAX_POS\");\n        require(\n            t.positionSizeWETH * t.leverage >=\n                pairsStored.pairMinLevPosWETH(t.pairIndex),\n            \"BELOW_MIN_POS\"\n        );\n\n        require(\n            t.leverage > 0 &&\n                t.leverage >= pairsStored.pairMinLeverage(t.pairIndex) &&\n                t.leverage <= pairMaxLeverage(pairsStored, t.pairIndex),\n            \"LEVERAGE_INCORRECT\"\n        );\n\n        // require(\n        //     spreadReductionId == 0 ||\n        //         storageT.nfts(spreadReductionId - 1).balanceOf(sender) > 0,\n        //     \"NO_CORRESPONDING_NFT_SPREAD_REDUCTION\"\n        // );\n\n        require(\n            t.tp == 0 || (t.buy ? t.tp > t.openPrice : t.tp < t.openPrice),\n            \"WRONG_TP\"\n        );\n        require(\n            t.sl == 0 || (t.buy ? t.sl < t.openPrice : t.sl > t.openPrice),\n            \"WRONG_SL\"\n        );\n\n        (uint priceImpactP, ) = pairInfos.getTradePriceImpact(\n            0,\n            t.pairIndex,\n            t.buy,\n            t.positionSizeWETH * t.leverage\n        );\n        require(\n            priceImpactP * t.leverage <= pairInfos.maxNegativePnlOnOpenP(),\n            \"PRICE_IMPACT_TOO_HIGH\"\n        );\n\n        storageT.transferWETH(sender, address(storageT), t.positionSizeWETH);\n\n        if (orderType != NftRewardsInterfaceV6_3_1.OpenLimitOrderType.LEGACY) {\n            // uint index = storageT.firstEmptyOpenLimitIndex(sender, t.pairIndex);\n            // storageT.storeOpenLimitOrder(\n            //     StorageInterface.OpenLimitOrder(\n            //         sender,\n            //         t.pairIndex,\n            //         index,\n            //         t.positionSizeWETH,\n            //         spreadReductionId > 0\n            //             ? storageT.spreadReductionsP(spreadReductionId - 1)\n            //             : 0,\n            //         t.buy,\n            //         t.leverage,\n            //         t.tp,\n            //         t.sl,\n            //         t.openPrice,\n            //         t.openPrice,\n            //         block.number,\n            //         0\n            //     )\n            // );\n            // nftRewards.setOpenLimitOrderType(\n            //     sender,\n            //     t.pairIndex,\n            //     index,\n            //     orderType\n            // );\n            // address c = storageT.callbacks();\n            // c.setTradeLastUpdated(\n            //     sender,\n            //     t.pairIndex,\n            //     index,\n            //     TradingCallbacksInterface.TradeType.LIMIT,\n            //     ChainUtils.getBlockNumber()\n            // );\n            // c.setTradeData(\n            //     sender,\n            //     t.pairIndex,\n            //     index,\n            //     TradingCallbacksInterface.TradeType.LIMIT,\n            //     slippageP\n            // );\n            // emit OpenLimitPlaced(sender, t.pairIndex, index);\n        } else {\n            uint orderId = aggregator.getPrice(\n                t.pairIndex,\n                AggregatorInterfaceV1_4.OrderType.MARKET_OPEN,\n                t.positionSizeWETH * t.leverage,\n                ChainUtils.getBlockNumber()\n            );\n\n            // storageT.storePendingMarketOrder(\n            //     StorageInterface.PendingMarketOrder(\n            //         StorageInterface.Trade(\n            //             sender,\n            //             t.pairIndex,\n            //             0,\n            //             0,\n            //             t.positionSizeWETH,\n            //             0,\n            //             t.buy,\n            //             t.leverage,\n            //             t.tp,\n            //             t.sl\n            //         ),\n            //         0,\n            //         t.openPrice,\n            //         slippageP,\n            //         0,\n            //         0\n            //     ),\n            //     orderId,\n            //     true\n            // );\n\n            (storageT.priceAggregator()).marketOrderfulfill(\n                orderId,\n                StorageInterface.PendingMarketOrder(\n                    StorageInterface.Trade(\n                        sender,\n                        t.pairIndex,\n                        0,\n                        0,\n                        t.positionSizeWETH,\n                        0,\n                        t.buy,\n                        t.leverage,\n                        t.tp,\n                        t.sl\n                    ),\n                    0,\n                    t.openPrice,\n                    slippageP,\n                    0,\n                    0\n                )\n            );\n\n            emit MarketOrderInitiated(orderId, sender, t.pairIndex, true);\n        }\n\n        // referrals.registerPotentialReferrer(sender, referrer);\n    }\n\n    // Close trade (MARKET)\n    function closeTradeMarket(\n        uint pairIndex,\n        uint index\n    ) external notContract notDone {\n        address sender = _msgSender();\n        StorageInterface.Trade memory t = storageT.getOpenTrades(\n            sender,\n            pairIndex,\n            index\n        );\n\n        StorageInterface.TradeInfo memory i = storageT.getOpenTradesInfo(\n            sender,\n            pairIndex,\n            index\n        );\n\n        require(\n            storageT.pendingOrderIdsCount(sender) <\n                storageT.maxPendingMarketOrders(),\n            \"MAX_PENDING_ORDERS\"\n        );\n        require(!i.beingMarketClosed, \"ALREADY_BEING_CLOSED\");\n        require(t.leverage > 0, \"NO_TRADE\");\n\n        uint orderId = AggregatorInterfaceV1_4(\n            address(storageT.priceAggregator())\n        ).getPrice(\n                pairIndex,\n                AggregatorInterfaceV1_4.OrderType.MARKET_CLOSE,\n                (t.initialPosToken * i.tokenPriceWETH * t.leverage) / PRECISION,\n                ChainUtils.getBlockNumber()\n            );\n\n        // storageT.storePendingMarketOrder(\n        //     StorageInterface.PendingMarketOrder(\n        //         StorageInterface.Trade(\n        //             sender,\n        //             pairIndex,\n        //             index,\n        //             0,\n        //             0,\n        //             0,\n        //             false,\n        //             0,\n        //             0,\n        //             0\n        //         ),\n        //         0,\n        //         0,\n        //         0,\n        //         0,\n        //         0\n        //     ),\n        //     orderId,\n        //     false\n        // );\n\n        (storageT.priceAggregator()).marketOrderfulfill(\n            orderId,\n            StorageInterface.PendingMarketOrder(\n                StorageInterface.Trade(\n                    sender,\n                    pairIndex,\n                    index,\n                    0,\n                    0,\n                    0,\n                    false,\n                    0,\n                    0,\n                    0\n                ),\n                0,\n                0,\n                0,\n                0,\n                0\n            )\n        );\n\n        emit MarketOrderInitiated(orderId, sender, pairIndex, false);\n    }\n\n    // Manage limit order (OPEN)\n    // function updateOpenLimitOrder(\n    //     uint pairIndex,\n    //     uint index,\n    //     uint price, // PRECISION\n    //     uint tp,\n    //     uint sl,\n    //     uint maxSlippageP\n    // ) external notContract notDone {\n    //     require(price > 0, \"PRICE_ZERO\");\n\n    //     address sender = _msgSender();\n    //     require(\n    //         storageT.hasOpenLimitOrder(sender, pairIndex, index),\n    //         \"NO_LIMIT\"\n    //     );\n\n    //     StorageInterface.OpenLimitOrder memory o = storageT.getOpenLimitOrder(\n    //         sender,\n    //         pairIndex,\n    //         index\n    //     );\n\n    //     require(tp == 0 || (o.buy ? tp > price : tp < price), \"WRONG_TP\");\n    //     require(sl == 0 || (o.buy ? sl < price : sl > price), \"WRONG_SL\");\n\n    //     require(price * maxSlippageP < type(uint256).max, \"OVERFLOW\");\n\n    //     checkNoPendingTrigger(\n    //         sender,\n    //         pairIndex,\n    //         index,\n    //         StorageInterface.LimitOrder.OPEN\n    //     );\n\n    //     o.minPrice = price;\n    //     o.maxPrice = price;\n    //     o.tp = tp;\n    //     o.sl = sl;\n\n    //     storageT.updateOpenLimitOrder(o);\n\n    //     address c = storageT.callbacks();\n    //     c.setTradeLastUpdated(\n    //         sender,\n    //         pairIndex,\n    //         index,\n    //         TradingCallbacksInterface.TradeType.LIMIT,\n    //         ChainUtils.getBlockNumber()\n    //     );\n    //     c.setTradeData(\n    //         sender,\n    //         pairIndex,\n    //         index,\n    //         TradingCallbacksInterface.TradeType.LIMIT,\n    //         maxSlippageP\n    //     );\n\n    //     emit OpenLimitUpdated(\n    //         sender,\n    //         pairIndex,\n    //         index,\n    //         price,\n    //         tp,\n    //         sl,\n    //         maxSlippageP\n    //     );\n    // }\n\n    // function cancelOpenLimitOrder(\n    //     uint pairIndex,\n    //     uint index\n    // ) external notContract notDone {\n    //     address sender = _msgSender();\n    //     require(\n    //         storageT.hasOpenLimitOrder(sender, pairIndex, index),\n    //         \"NO_LIMIT\"\n    //     );\n\n    //     StorageInterface.OpenLimitOrder memory o = storageT.getOpenLimitOrder(\n    //         sender,\n    //         pairIndex,\n    //         index\n    //     );\n\n    //     checkNoPendingTrigger(\n    //         sender,\n    //         pairIndex,\n    //         index,\n    //         StorageInterface.LimitOrder.OPEN\n    //     );\n\n    //     storageT.unregisterOpenLimitOrder(sender, pairIndex, index);\n    //     storageT.transferWETH(address(storageT), sender, o.positionSize);\n\n    //     emit OpenLimitCanceled(sender, pairIndex, index);\n    // }\n\n    // Manage limit order (TP/SL)\n    function updateTp(\n        uint pairIndex,\n        uint index,\n        uint newTp\n    ) external notContract notDone {\n        address sender = _msgSender();\n\n        // checkNoPendingTrigger(\n        //     sender,\n        //     pairIndex,\n        //     index,\n        //     StorageInterface.LimitOrder.TP\n        // );\n        StorageInterface.Trade memory t = storageT.getOpenTrades(\n            sender,\n            pairIndex,\n            index\n        );\n        require(t.leverage > 0, \"NO_TRADE\");\n\n        storageT.updateTp(sender, pairIndex, index, newTp);\n        address(storageT.callbacks()).setTpLastUpdated(\n            sender,\n            pairIndex,\n            index,\n            TradingCallbacksInterface.TradeType.MARKET,\n            ChainUtils.getBlockNumber()\n        );\n\n        emit TpUpdated(sender, pairIndex, index, newTp);\n    }\n\n    function updateSl(\n        uint pairIndex,\n        uint index,\n        uint newSl\n    ) external notContract notDone {\n        address sender = _msgSender();\n\n        // checkNoPendingTrigger(\n        //     sender,\n        //     pairIndex,\n        //     index,\n        //     StorageInterface.LimitOrder.SL\n        // );\n\n        StorageInterface.Trade memory t = storageT.getOpenTrades(\n            sender,\n            pairIndex,\n            index\n        );\n        require(t.leverage > 0, \"NO_TRADE\");\n\n        uint maxSlDist = (t.openPrice * MAX_SL_P) / 100 / t.leverage;\n\n        require(\n            newSl == 0 ||\n                (\n                    t.buy\n                        ? newSl >= t.openPrice - maxSlDist\n                        : newSl <= t.openPrice + maxSlDist\n                ),\n            \"SL_TOO_BIG\"\n        );\n\n        storageT.updateSl(sender, pairIndex, index, newSl);\n        address(storageT.callbacks()).setSlLastUpdated(\n            sender,\n            pairIndex,\n            index,\n            TradingCallbacksInterface.TradeType.MARKET,\n            ChainUtils.getBlockNumber()\n        );\n\n        emit SlUpdated(sender, pairIndex, index, newSl);\n    }\n\n    function executeNftOrders(\n        uint[100] memory _orderTypes,\n        address[100] memory traders,\n        uint[100] memory pairIndexs,\n        uint[100] memory indexs\n    ) public  notDone {\n        for (uint i; i < _orderTypes.length; i++) {\n            if (traders[i] != address(0)) {\n                executeNftOrder(\n                    _orderTypes[i],\n                    traders[i],\n                    pairIndexs[i],\n                    indexs[i],\n                    1,\n                    1\n                );\n            }\n        }\n    }\n\n    // Execute limit order\n    function executeNftOrder(\n        uint _orderType,\n        address trader,\n        uint pairIndex,\n        uint index,\n        uint nftId,\n        uint nftType\n    ) public  notDone {\n        // (\n        //     uint _orderType,\n        //     address trader,\n        //     uint pairIndex,\n        //     uint index,\n        //     uint nftId,\n        //     uint nftType\n        // ) = packed.unpackExecuteNftOrder();\n        StorageInterface.LimitOrder orderType = StorageInterface.LimitOrder(\n            _orderType\n        );\n        address sender = _msgSender();\n\n        // require(nftType >= 1 && nftType <= 5, \"WRONG_NFT_TYPE\");\n        // require(storageT.nfts(nftType - 1).ownerOf(nftId) == sender, \"NO_NFT\");\n\n        // require(\n        //     block.number >=\n        //         storageT.nftLastSuccess(nftId) + storageT.nftSuccessTimelock(),\n        //     \"SUCCESS_TIMELOCK\"\n        // );\n\n        bool isOpenLimit = orderType == StorageInterface.LimitOrder.OPEN;\n        TradingCallbacksInterface.TradeType tradeType = isOpenLimit\n            ? TradingCallbacksInterface.TradeType.LIMIT\n            : TradingCallbacksInterface.TradeType.MARKET;\n\n        // require(\n        //     canExecute(\n        //         orderType,\n        //         TradingCallbacksInterface.SimplifiedTradeId(\n        //             trader,\n        //             pairIndex,\n        //             index,\n        //             tradeType\n        //         )\n        //     ),\n        //     \"IN_TIMEOUT\"\n        // );\n\n        // handleBotInUse(sender, nftId, trader, pairIndex, index);\n\n        StorageInterface.Trade memory t;\n\n        if (isOpenLimit) {\n            revert(\"Open Limit orders not supported yet\");\n            // require(\n            //     storageT.hasOpenLimitOrder(trader, pairIndex, index),\n            //     \"NO_LIMIT\"\n            // );\n        } else {\n            t = storageT.getOpenTrades(trader, pairIndex, index);\n\n            require(t.leverage > 0, \"NO_TRADE\");\n\n            if (orderType == StorageInterface.LimitOrder.LIQ) {\n                uint liqPrice = borrowingFees.getTradeLiquidationPrice(\n                    BorrowingFeesInterface.LiqPriceInput(\n                        t.trader,\n                        t.pairIndex,\n                        t.index,\n                        t.openPrice,\n                        t.buy,\n                        t.positionSizeWETH,\n                        t.leverage\n                    )\n                );\n\n                require(\n                    t.sl == 0 || (t.buy ? liqPrice > t.sl : liqPrice < t.sl),\n                    \"HAS_SL\"\n                );\n            } else if (orderType == StorageInterface.LimitOrder.PAR_LIQ) {\n                uint parLiqPrice = borrowingFees\n                    .getTradePartialLiquidationPrice(\n                        BorrowingFeesInterface.LiqPriceInput(\n                            t.trader,\n                            t.pairIndex,\n                            t.index,\n                            t.openPrice,\n                            t.buy,\n                            t.positionSizeWETH,\n                            t.leverage\n                        )\n                    );\n\n                require(\n                    t.sl == 0 ||\n                        (t.buy ? parLiqPrice > t.sl : parLiqPrice < t.sl),\n                    \"HAS_SL\"\n                );\n                int256 pnl = callbacks.getTradePnl(\n                    t.trader,\n                    t.pairIndex,\n                    t.index\n                );\n                int256 position = int(t.positionSizeWETH) + pnl;\n                require(\n                    position * int256(t.leverage) >= minLeveragedPosWETH,\n                    \"position to small for partial liquidation\"\n                );\n            } else {\n                require(\n                    orderType != StorageInterface.LimitOrder.SL || t.sl > 0,\n                    \"NO_SL\"\n                );\n                require(\n                    orderType != StorageInterface.LimitOrder.TP || t.tp > 0,\n                    \"NO_TP\"\n                );\n            }\n        }\n\n        // NftRewardsInterfaceV6_3_1.TriggeredLimitId\n        //     memory triggeredLimitId = NftRewardsInterfaceV6_3_1\n        //         .TriggeredLimitId(trader, pairIndex, index, orderType);\n\n        if (\n            true\n            // !nftRewards.triggered(triggeredLimitId) ||\n            // nftRewards.timedOut(triggeredLimitId)\n        ) {\n            uint leveragedPosWETH;\n\n            if (isOpenLimit) {\n                // StorageInterface.OpenLimitOrder memory l = storageT\n                //     .getOpenLimitOrder(trader, pairIndex, index);\n                // leveragedPosWETH = l.positionSize * l.leverage;\n                // (uint priceImpactP, ) = pairInfos.getTradePriceImpact(\n                //     0,\n                //     l.pairIndex,\n                //     l.buy,\n                //     leveragedPosWETH\n                // );\n                // require(\n                //     priceImpactP * l.leverage <=\n                //         pairInfos.maxNegativePnlOnOpenP(),\n                //     \"PRICE_IMPACT_TOO_HIGH\"\n                // );\n            } else {\n                leveragedPosWETH = t.positionSizeWETH * t.leverage;\n            }\n\n            // storageT.transferLinkToAggregator(\n            //     sender,\n            //     pairIndex,\n            //     leveragedPosWETH\n            // );\n\n            (uint orderId /*uint linkFee*/, ) = getPriceNftOrder(\n                isOpenLimit,\n                trader,\n                pairIndex,\n                index,\n                tradeType,\n                orderType,\n                leveragedPosWETH\n            );\n\n            StorageInterface.PendingNftOrder memory pendingNftOrder;\n            pendingNftOrder.nftHolder = sender;\n            pendingNftOrder.nftId = nftId;\n            pendingNftOrder.trader = trader;\n            pendingNftOrder.pairIndex = pairIndex;\n            pendingNftOrder.index = index;\n            pendingNftOrder.orderType = orderType;\n            storageT.storePendingNftOrder(pendingNftOrder, orderId);\n\n            (storageT.priceAggregator()).nftOrderfulfill(\n                orderId,\n                pendingNftOrder\n            );\n            emit NftOrderInitiated(orderId, sender, trader, pairIndex);\n        } else {\n            // nftRewards.storeTriggerSameBlock(triggeredLimitId, sender);\n\n            emit NftOrderSameBlock(sender, trader, pairIndex);\n        }\n    }\n\n    // Market timeout\n    // function openTradeMarketTimeout(uint _order) external notContract notDone {\n    //     address sender = _msgSender();\n\n    //     StorageInterface.PendingMarketOrder memory o = storageT\n    //         .reqID_pendingMarketOrder(_order);\n    //     StorageInterface.Trade memory t = o.trade;\n\n    //     require(\n    //         o.block > 0 && block.number >= o.block + marketOrdersTimeout,\n    //         \"WAIT_TIMEOUT\"\n    //     );\n    //     require(t.trader == sender, \"NOT_YOUR_ORDER\");\n    //     require(t.leverage > 0, \"WRONG_MARKET_ORDER_TYPE\");\n\n    //     storageT.unregisterPendingMarketOrder(_order, true);\n    //     storageT.transferWETH(address(storageT), sender, t.positionSizeWETH);\n\n    //     emit ChainlinkCallbackTimeout(_order, o);\n    // }\n\n    // function closeTradeMarketTimeout(uint _order) external notContract notDone {\n    //     address sender = _msgSender();\n\n    //     StorageInterface.PendingMarketOrder memory o = storageT\n    //         .reqID_pendingMarketOrder(_order);\n    //     StorageInterface.Trade memory t = o.trade;\n\n    //     require(\n    //         o.block > 0 && block.number >= o.block + marketOrdersTimeout,\n    //         \"WAIT_TIMEOUT\"\n    //     );\n    //     require(t.trader == sender, \"NOT_YOUR_ORDER\");\n    //     require(t.leverage == 0, \"WRONG_MARKET_ORDER_TYPE\");\n\n    //     storageT.unregisterPendingMarketOrder(_order, false);\n\n    //     (bool success, ) = address(this).delegatecall(\n    //         abi.encodeWithSignature(\n    //             \"closeTradeMarket(uint256,uint256)\",\n    //             t.pairIndex,\n    //             t.index\n    //         )\n    //     );\n\n    //     if (!success) {\n    //         emit CouldNotCloseTrade(sender, t.pairIndex, t.index);\n    //     }\n\n    //     emit ChainlinkCallbackTimeout(_order, o);\n    // }\n\n    // //Helpers\n    // function checkNoPendingTrigger(\n    //     address trader,\n    //     uint pairIndex,\n    //     uint index,\n    //     StorageInterface.LimitOrder orderType\n    // ) private view {\n    //     NftRewardsInterfaceV6_3_1.TriggeredLimitId\n    //         memory triggeredLimitId = NftRewardsInterfaceV6_3_1\n    //             .TriggeredLimitId(trader, pairIndex, index, orderType);\n    //     require(\n    //         !nftRewards.triggered(triggeredLimitId) ||\n    //             nftRewards.timedOut(triggeredLimitId),\n    //         \"PENDING_TRIGGER\"\n    //     );\n    // }\n\n    // function canExecute(\n    //     StorageInterface.LimitOrder orderType,\n    //     TradingCallbacksInterface.SimplifiedTradeId memory id\n    // ) private view returns (bool) {\n    //     if (orderType == StorageInterface.LimitOrder.LIQ) return true;\n\n    //     uint b = ChainUtils.getBlockNumber();\n    //     address cb = storageT.callbacks();\n\n    //     if (orderType == StorageInterface.LimitOrder.TP)\n    //         return !cb.isTpInTimeout(id, b);\n    //     if (orderType == StorageInterface.LimitOrder.SL)\n    //         return !cb.isSlInTimeout(id, b);\n\n    //     return !cb.isLimitInTimeout(id, b);\n    // }\n\n    function pairMaxLeverage(\n        PairsStorageInterfaceV6 pairsStored,\n        uint pairIndex\n    ) private view returns (uint) {\n        uint max = TradingCallbacksInterface(address(storageT.callbacks()))\n            .pairMaxLeverage(pairIndex);\n        return max > 0 ? max : pairsStored.pairMaxLeverage(pairIndex);\n    }\n\n    // function handleBotInUse(\n    //     address sender,\n    //     uint nftId,\n    //     address trader,\n    //     uint pairIndex,\n    //     uint index\n    // ) private {\n    //     (bytes32 nftHash, bytes32 botHash) = nftRewards.getNftBotHashes(\n    //         block.number,\n    //         sender,\n    //         nftId,\n    //         trader,\n    //         pairIndex,\n    //         index\n    //     );\n    //     require(!nftRewards.nftBotInUse(nftHash, botHash), \"BOT_IN_USE\");\n\n    //     nftRewards.setNftBotInUse(nftHash, botHash);\n    // }\n\n    function getPriceNftOrder(\n        bool isOpenLimit,\n        address trader,\n        uint pairIndex,\n        uint index,\n        TradingCallbacksInterface.TradeType tradeType,\n        StorageInterface.LimitOrder orderType,\n        uint leveragedPosWETH\n    ) private returns (uint orderId, uint linkFee) {\n        TradingCallbacksInterface.LastUpdated\n            memory lastUpdated = TradingCallbacksInterface(\n                address(storageT.callbacks())\n            ).tradeLastUpdated(trader, pairIndex, index, tradeType);\n\n        AggregatorInterfaceV1_4 aggregator = AggregatorInterfaceV1_4(\n            address(storageT.priceAggregator())\n        );\n\n        orderId = aggregator.getPrice(\n            pairIndex,\n            isOpenLimit\n                ? AggregatorInterfaceV1_4.OrderType.LIMIT_OPEN\n                : AggregatorInterfaceV1_4.OrderType.LIMIT_CLOSE,\n            leveragedPosWETH,\n            isOpenLimit\n                ? lastUpdated.limit\n                : orderType == StorageInterface.LimitOrder.SL\n                ? lastUpdated.sl\n                : orderType == StorageInterface.LimitOrder.TP\n                ? lastUpdated.tp\n                : lastUpdated.created\n        );\n\n        // linkFee = aggregator.linkFee(pairIndex, leveragedPosWETH);\n    }\n\n    function isTradeLiquidatable(\n        address trader,\n        uint pairIndex,\n        uint index\n    ) external view returns (bool) {\n        StorageInterface.Trade memory t = storageT.getOpenTrades(\n            trader,\n            pairIndex,\n            index\n        );\n\n        (bool liquidatable, bool noSL) = isTradeLiquidatablePure(t);\n\n        require(noSL, \"HAS_SL\");\n\n        return liquidatable;\n    }\n\n    function isTradeLiquidatablePure(\n        StorageInterface.Trade memory t\n    ) public view returns (bool, bool) {\n        if (t.leverage == 0) return (false, false);\n        uint liqPrice = borrowingFees.getTradeLiquidationPrice(\n            BorrowingFeesInterface.LiqPriceInput(\n                t.trader,\n                t.pairIndex,\n                t.index,\n                t.openPrice,\n                t.buy,\n                t.positionSizeWETH,\n                t.leverage\n            )\n        );\n        (uint256 price, uint256 lastUpdateTime) = (storageT.oracle()).getPrice(\n            t.pairIndex\n        );\n        bool noSL = t.sl == 0 || (t.buy ? liqPrice > t.sl : liqPrice < t.sl);\n\n        return (price <= liqPrice, noSL);\n    }\n\n    function isTradeParLiquidatable(\n        address trader,\n        uint pairIndex,\n        uint index\n    ) external view returns (bool) {\n        StorageInterface.Trade memory t = storageT.getOpenTrades(\n            trader,\n            pairIndex,\n            index\n        );\n\n        (uint256 price, uint256 lastUpdateTime) = (storageT.oracle()).getPrice(\n            pairIndex\n        );\n\n        (bool parLiquidatable, bool noSL) = isTradeParLiquidatablePure(t);\n\n        require(noSL, \"HAS_SL\");\n\n        return parLiquidatable;\n    }\n\n    function isTradeParLiquidatablePure(\n        StorageInterface.Trade memory t\n    ) public view returns (bool, bool) {\n        if (t.leverage == 0) return (false, false);\n\n        uint parLiqPrice = borrowingFees.getTradePartialLiquidationPrice(\n            BorrowingFeesInterface.LiqPriceInput(\n                t.trader,\n                t.pairIndex,\n                t.index,\n                t.openPrice,\n                t.buy,\n                t.positionSizeWETH,\n                t.leverage\n            )\n        );\n        (uint256 price, uint256 lastUpdateTime) = (storageT.oracle()).getPrice(\n            t.pairIndex\n        );\n        bool noSL = t.sl == 0 ||\n            (t.buy ? parLiqPrice > t.sl : parLiqPrice < t.sl);\n\n        return (price <= parLiqPrice, noSL);\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 125
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}