{
  "language": "Solidity",
  "sources": {
    "contracts/Delegatable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nabstract contract Delegatable {\n    mapping(address => address) public delegations;\n    address private senderOverride;\n\n    function setDelegate(address delegate) external {\n        require(tx.origin == msg.sender, \"NO_CONTRACT\");\n\n        delegations[msg.sender] = delegate;\n    }\n\n    function removeDelegate() external {\n        delegations[msg.sender] = address(0);\n    }\n\n    function delegatedAction(address trader, bytes calldata call_data) external returns (bytes memory) {\n        require(delegations[trader] == msg.sender, \"DELEGATE_NOT_APPROVED\");\n\n        senderOverride = trader;\n        (bool success, bytes memory result) = address(this).delegatecall(call_data);\n        if (!success) {\n            // Next 5 lines from https://ethereum.stackexchange.com/a/83577 (return the original revert reason)\n            if (result.length < 68) revert();\n            assembly {\n                result := add(result, 0x04)\n            }\n            revert(abi.decode(result, (string)));\n        }\n\n        senderOverride = address(0);\n\n        return result;\n    }\n\n    function _msgSender() public view returns (address) {\n        if (senderOverride == address(0)) {\n            return msg.sender;\n        } else {\n            return senderOverride;\n        }\n    }\n}"
    },
    "contracts/interfaces/AggregatorInterfaceV1_1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./PairsStorageInterfaceV6.sol\";\nimport \"./NftRewardsInterfaceV6.sol\";\n\ninterface AggregatorInterfaceV1_1 {\n    enum OrderType {\n        MARKET_OPEN,\n        MARKET_CLOSE,\n        LIMIT_OPEN,\n        LIMIT_CLOSE,\n        UPDATE_SL\n    }\n\n    function pairsStorage() external view returns (PairsStorageInterfaceV6);\n\n    function nftRewards() external view returns (NftRewardsInterfaceV6);\n\n    function getPrice(uint, OrderType, uint) external returns (uint);\n\n    function tokenPriceWETH() external view returns (uint);\n\n    function linkFee(uint, uint) external view returns (uint);\n\n    function tokenWETHReservesLp() external view returns (uint, uint);\n\n    function pendingSlOrders(uint) external view returns (PendingSl memory);\n\n    function storePendingSlOrder(uint orderId, PendingSl calldata p) external;\n\n    function unregisterPendingSlOrder(uint orderId) external;\n\n    struct PendingSl {\n        address trader;\n        uint pairIndex;\n        uint index;\n        uint openPrice;\n        bool buy;\n        uint newSl;\n    }\n}\n"
    },
    "contracts/interfaces/AggregatorInterfaceV1_4.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\nimport \"./PairsStorageInterfaceV6.sol\";\nimport \"./ChainlinkFeedInterface.sol\";\n\ninterface AggregatorInterfaceV1_4 {\n    enum OrderType {\n        MARKET_OPEN,\n        MARKET_CLOSE,\n        LIMIT_OPEN,\n        LIMIT_CLOSE\n    }\n\n    function pairsStorage() external view returns (PairsStorageInterfaceV6);\n\n    function getPrice(uint, OrderType, uint, uint) external returns (uint);\n\n    function tokenPriceWETH() external returns (uint);\n\n    function linkFee(uint, uint) external view returns (uint);\n\n    function openFeeP(uint) external view returns (uint);\n\n    function linkPriceFeed() external view returns (ChainlinkFeedInterface);\n}\n"
    },
    "contracts/interfaces/AggregatorInterfaceV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface AggregatorInterfaceV1 {\n    enum OrderType {\n        MARKET_OPEN,\n        MARKET_CLOSE,\n        LIMIT_OPEN,\n        LIMIT_CLOSE\n    }\n\n    function getPrice(uint, OrderType, uint) external returns (uint);\n\n    function tokenPriceWETH() external view returns (uint);\n\n    function pairMinOpenLimitSlippageP(uint) external view returns (uint);\n\n    function closeFeeP(uint) external view returns (uint);\n\n    function linkFee(uint, uint) external view returns (uint);\n\n    function openFeeP(uint) external view returns (uint);\n\n    function pairMinLeverage(uint) external view returns (uint);\n\n    function pairMaxLeverage(uint) external view returns (uint);\n\n    function pairsCount() external view returns (uint);\n\n    function tokenWETHReservesLp() external view returns (uint, uint);\n\n    function referralP(uint) external view returns (uint);\n\n    function nftLimitOrderFeeP(uint) external view returns (uint);\n}\n"
    },
    "contracts/interfaces/BorrowingFeesInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface BorrowingFeesInterface {\n    // Structs\n    struct PairGroup {\n        uint16 groupIndex;\n        uint48 block;\n        uint64 initialAccFeeLong; // 1e10 (%)\n        uint64 initialAccFeeShort; // 1e10 (%)\n        uint64 prevGroupAccFeeLong; // 1e10 (%)\n        uint64 prevGroupAccFeeShort; // 1e10 (%)\n        uint64 pairAccFeeLong; // 1e10 (%)\n        uint64 pairAccFeeShort; // 1e10 (%)\n        uint64 _placeholder; // might be useful later\n    }\n    struct Pair {\n        PairGroup[] groups;\n        uint32 feePerBlock; // 1e10 (%)\n        uint64 accFeeLong; // 1e10 (%)\n        uint64 accFeeShort; // 1e10 (%)\n        uint48 accLastUpdatedBlock;\n        uint48 feeExponent;\n        uint lastAccBlockWeightedMarketCap; // 1e40\n    }\n    struct PairOi {\n        uint72 long; // 1e10 (DAI)\n        uint72 short; // 1e10 (DAI)\n        uint72 max; // 1e10 (DAI)\n        uint40 _placeholder; // might be useful later\n    }\n    struct Group {\n        uint112 oiLong; // 1e10\n        uint112 oiShort; // 1e10\n        uint32 feePerBlock; // 1e10 (%)\n        uint64 accFeeLong; // 1e10 (%)\n        uint64 accFeeShort; // 1e10 (%)\n        uint48 accLastUpdatedBlock;\n        uint80 maxOi; // 1e10\n        uint lastAccBlockWeightedMarketCap; // 1e40\n    }\n    struct InitialAccFees {\n        uint64 accPairFee; // 1e10 (%)\n        uint64 accGroupFee; // 1e10 (%)\n        uint48 block;\n        uint80 _placeholder; // might be useful later\n    }\n    struct PairParams {\n        uint16 groupIndex;\n        uint32 feePerBlock; // 1e10 (%)\n        uint48 feeExponent;\n        uint72 maxOi;\n    }\n    struct GroupParams {\n        uint32 feePerBlock; // 1e10 (%)\n        uint72 maxOi; // 1e10\n        uint48 feeExponent;\n    }\n    struct BorrowingFeeInput {\n        address trader;\n        uint pairIndex;\n        uint index;\n        bool long;\n        uint collateral; // 1e18 (DAI)\n        uint leverage;\n    }\n    struct LiqPriceInput {\n        address trader;\n        uint pairIndex;\n        uint index;\n        uint openPrice; // 1e10\n        bool long;\n        uint collateral; // 1e18 (DAI)\n        uint leverage;\n    }\n    struct PendingAccFeesInput {\n        uint64 accFeeLong; // 1e10 (%)\n        uint64 accFeeShort; // 1e10 (%)\n        uint oiLong; // 1e18\n        uint oiShort; // 1e18\n        uint32 feePerBlock; // 1e10\n        uint currentBlock;\n        uint accLastUpdatedBlock;\n        uint72 maxOi; // 1e10\n        uint48 feeExponent;\n    }\n\n    // Events\n    event PairParamsUpdated(\n        uint indexed pairIndex,\n        uint16 indexed groupIndex,\n        uint32 feePerBlock,\n        uint48 feeExponent,\n        uint72 maxOi\n    );\n    event PairGroupUpdated(\n        uint indexed pairIndex,\n        uint16 indexed prevGroupIndex,\n        uint16 indexed newGroupIndex\n    );\n    event GroupUpdated(\n        uint16 indexed groupIndex,\n        uint32 feePerBlock,\n        uint72 maxOi,\n        uint48 feeExponent\n    );\n    event TradeInitialAccFeesStored(\n        address indexed trader,\n        uint indexed pairIndex,\n        uint index,\n        uint64 initialPairAccFee,\n        uint64 initialGroupAccFee\n    );\n    event TradeActionHandled(\n        address indexed trader,\n        uint indexed pairIndex,\n        uint index,\n        bool open,\n        bool long,\n        uint positionSizeDai // 1e18\n    );\n    event PairAccFeesUpdated(\n        uint indexed pairIndex,\n        uint currentBlock,\n        uint64 accFeeLong,\n        uint64 accFeeShort\n    );\n    event GroupAccFeesUpdated(\n        uint16 indexed groupIndex,\n        uint currentBlock,\n        uint64 accFeeLong,\n        uint64 accFeeShort\n    );\n    event GroupOiUpdated(\n        uint16 indexed groupIndex,\n        bool indexed long,\n        bool indexed increase,\n        uint112 amount,\n        uint112 oiLong,\n        uint112 oiShort\n    );\n\n    // Functions\n    function getTradeLiquidationPrice(\n        LiqPriceInput calldata\n    ) external view returns (uint); // PRECISION\n\n    function getTradeBorrowingFee(\n        BorrowingFeeInput memory\n    ) external view returns (uint); // 1e18 (DAI)\n\n    function handleTradeAction(\n        address trader,\n        uint pairIndex,\n        uint index,\n        uint positionSizeDai, // 1e18 (collateral * leverage)\n        bool open,\n        bool long\n    ) external;\n\n    function withinMaxGroupOi(\n        uint pairIndex,\n        bool long,\n        uint positionSizeDai\n    ) external view returns (bool);\n\n    function getPairMaxOi(uint pairIndex) external view returns (uint);\n}\n"
    },
    "contracts/interfaces/ChainlinkFeedInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface ChainlinkFeedInterface {\n    function latestRoundData()\n        external\n        view\n        returns (uint80, int, uint, uint, uint80);\n}\n"
    },
    "contracts/interfaces/IArbSys.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.21 <0.9.0;\n\n/**\n * @title Precompiled contract that exists in every Arbitrum chain at address(100), 0x0000000000000000000000000000000000000064. Exposes a variety of system-level functionality.\n */\ninterface IArbSys {\n    /**\n     * @notice Get internal version number identifying an ArbOS build\n     * @return version number as int\n     */\n    function arbOSVersion() external pure returns (uint);\n\n    function arbChainID() external view returns (uint);\n\n    /**\n     * @notice Get Arbitrum block number (distinct from L1 block number; Arbitrum genesis block has block number 0)\n     * @return block number as int\n     */\n    function arbBlockNumber() external view returns (uint);\n\n    /**\n     * @notice Send given amount of Eth to dest from sender.\n     * This is a convenience function, which is equivalent to calling sendTxToL1 with empty calldataForL1.\n     * @param destination recipient address on L1\n     * @return unique identifier for this L2-to-L1 transaction.\n     */\n    function withdrawEth(address destination) external payable returns (uint);\n\n    /**\n     * @notice Send a transaction to L1\n     * @param destination recipient address on L1\n     * @param calldataForL1 (optional) calldata for L1 contract call\n     * @return a unique identifier for this L2-to-L1 transaction.\n     */\n    function sendTxToL1(address destination, bytes calldata calldataForL1) external payable returns (uint);\n\n    /**\n     * @notice get the number of transactions issued by the given external account or the account sequence number of the given contract\n     * @param account target account\n     * @return the number of transactions issued by the given external account or the account sequence number of the given contract\n     */\n    function getTransactionCount(address account) external view returns (uint256);\n\n    /**\n     * @notice get the value of target L2 storage slot\n     * This function is only callable from address 0 to prevent contracts from being able to call it\n     * @param account target account\n     * @param index target index of storage slot\n     * @return stotage value for the given account at the given index\n     */\n    function getStorageAt(address account, uint256 index) external view returns (uint256);\n\n    /**\n     * @notice check if current call is coming from l1\n     * @return true if the caller of this was called directly from L1\n     */\n    function isTopLevelCall() external view returns (bool);\n\n    /**\n     * @notice check if the caller (of this caller of this) is an aliased L1 contract address\n     * @return true iff the caller's address is an alias for an L1 contract address\n     */\n    function wasMyCallersAddressAliased() external view returns (bool);\n\n    /**\n     * @notice return the address of the caller (of this caller of this), without applying L1 contract address aliasing\n     * @return address of the caller's caller, without applying L1 contract address aliasing\n     */\n    function myCallersAddressWithoutAliasing() external view returns (address);\n\n    /**\n     * @notice map L1 sender contract address to its L2 alias\n     * @param sender sender address\n     * @param dest destination address\n     * @return aliased sender address\n     */\n    function mapL1SenderContractAddressToL2Alias(address sender, address dest) external pure returns (address);\n\n    /**\n     * @notice get the caller's amount of available storage gas\n     * @return amount of storage gas available to the caller\n     */\n    function getStorageGasAvailable() external view returns (uint);\n\n    event L2ToL1Transaction(\n        address caller,\n        address indexed destination,\n        uint indexed uniqueId,\n        uint indexed batchNumber,\n        uint indexInBatch,\n        uint arbBlockNum,\n        uint ethBlockNum,\n        uint timestamp,\n        uint callvalue,\n        bytes data\n    );\n}"
    },
    "contracts/interfaces/IGToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IGToken {\n    function manager() external view returns (address);\n\n    function admin() external view returns (address);\n\n    function currentEpoch() external view returns (uint);\n\n    function currentEpochStart() external view returns (uint);\n\n    function currentEpochPositiveOpenPnl() external view returns (uint);\n\n    function updateAccPnlPerTokenUsed(\n        uint prevPositiveOpenPnl,\n        uint newPositiveOpenPnl\n    ) external returns (uint);\n\n    struct LockedDeposit {\n        address owner;\n        uint shares; // 1e18\n        uint assetsDeposited; // 1e18\n        uint assetsDiscount; // 1e18\n        uint atTimestamp; // timestamp\n        uint lockDuration; // timestamp\n    }\n\n    function getLockedDeposit(\n        uint depositId\n    ) external view returns (LockedDeposit memory);\n\n    function sendAssets(uint assets, address receiver) external;\n\n    function receiveAssets(uint assets, address user) external;\n\n    function distributeReward(uint assets) external;\n\n    function currentBalanceWETH() external view returns (uint);\n\n    function tvl() external view returns (uint);\n\n    function marketCap() external view returns (uint);\n\n    function getPendingAccBlockWeightedMarketCap(\n        uint currentBlock\n    ) external view returns (uint);\n}\n"
    },
    "contracts/interfaces/NftInterfaceV5.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface NftInterfaceV5 {\n    function balanceOf(address) external view returns (uint);\n\n    function ownerOf(uint) external view returns (address);\n\n    function transferFrom(address, address, uint) external;\n\n    function tokenOfOwnerByIndex(address, uint) external view returns (uint);\n}\n"
    },
    "contracts/interfaces/NFTRewardInterfaceV6_3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./StorageInterface.sol\";\n\ninterface NftRewardsInterfaceV6_3_1 {\n    struct TriggeredLimitId {\n        address trader;\n        uint pairIndex;\n        uint index;\n        StorageInterface.LimitOrder order;\n    }\n    enum OpenLimitOrderType {\n        LEGACY,\n        REVERSAL,\n        MOMENTUM\n    }\n\n    function storeFirstToTrigger(\n        TriggeredLimitId calldata,\n        address,\n        uint\n    ) external;\n\n    function storeTriggerSameBlock(TriggeredLimitId calldata, address) external;\n\n    function unregisterTrigger(TriggeredLimitId calldata) external;\n\n    function distributeNftReward(\n        TriggeredLimitId calldata,\n        uint,\n        uint\n    ) external;\n\n    function openLimitOrderTypes(\n        address,\n        uint,\n        uint\n    ) external view returns (OpenLimitOrderType);\n\n    function setOpenLimitOrderType(\n        address,\n        uint,\n        uint,\n        OpenLimitOrderType\n    ) external;\n\n    function triggered(TriggeredLimitId calldata) external view returns (bool);\n\n    function timedOut(TriggeredLimitId calldata) external view returns (bool);\n\n    function botInUse(bytes32) external view returns (bool);\n\n    function getNftBotHashes(\n        uint,\n        address,\n        uint,\n        address,\n        uint,\n        uint\n    ) external pure returns (bytes32, bytes32);\n\n    function setNftBotInUse(bytes32, bytes32) external;\n\n    function nftBotInUse(bytes32, bytes32) external view returns (bool);\n\n    function linkToTokenRewards(uint, uint) external view returns (uint);\n}\n"
    },
    "contracts/interfaces/NftRewardsInterfaceV6.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./StorageInterface.sol\";\n\ninterface NftRewardsInterfaceV6 {\n    struct TriggeredLimitId {\n        address trader;\n        uint pairIndex;\n        uint index;\n        StorageInterface.LimitOrder order;\n    }\n    enum OpenLimitOrderType {\n        LEGACY,\n        REVERSAL,\n        MOMENTUM\n    }\n\n    function storeFirstToTrigger(TriggeredLimitId calldata, address) external;\n\n    function storeTriggerSameBlock(TriggeredLimitId calldata, address) external;\n\n    function unregisterTrigger(TriggeredLimitId calldata) external;\n\n    function distributeNftReward(TriggeredLimitId calldata, uint) external;\n\n    function openLimitOrderTypes(\n        address,\n        uint,\n        uint\n    ) external view returns (OpenLimitOrderType);\n\n    function setOpenLimitOrderType(\n        address,\n        uint,\n        uint,\n        OpenLimitOrderType\n    ) external;\n\n    function triggered(TriggeredLimitId calldata) external view returns (bool);\n\n    function timedOut(TriggeredLimitId calldata) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/PairInfosInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface PairInfosInterface {\n    // Trade initial acc fees\n    struct TradeInitialAccFees {\n        uint rollover; // 1e18 (DAI)\n        int funding; // 1e18 (DAI)\n        bool openedAfterUpdate;\n    }\n\n    function tradeInitialAccFees(\n        address,\n        uint,\n        uint\n    ) external view returns (TradeInitialAccFees memory);\n\n    function maxNegativePnlOnOpenP() external view returns (uint); // PRECISION (%)\n\n    function storeTradeInitialAccFees(\n        address trader,\n        uint pairIndex,\n        uint index,\n        bool long\n    ) external;\n\n    function getTradePriceImpact(\n        uint openPrice, // PRECISION\n        uint pairIndex,\n        bool long,\n        uint openInterest // 1e18 (DAI)\n    )\n        external\n        view\n        returns (\n            uint priceImpactP, // PRECISION (%)\n            uint priceAfterImpact // PRECISION\n        );\n\n    function getTradeRolloverFee(\n        address trader,\n        uint pairIndex,\n        uint index,\n        uint collateral // 1e18 (DAI)\n    ) external view returns (uint);\n\n    function getTradeFundingFee(\n        address trader,\n        uint pairIndex,\n        uint index,\n        bool long,\n        uint collateral, // 1e18 (DAI)\n        uint leverage\n    )\n        external\n        view\n        returns (\n            int // 1e18 (DAI) | Positive => Fee, Negative => Reward\n        );\n\n    function getTradeLiquidationPricePure(\n        uint openPrice, // PRECISION\n        bool long,\n        uint collateral, // 1e18 (DAI)\n        uint leverage,\n        uint rolloverFee, // 1e18 (DAI)\n        int fundingFee // 1e18 (DAI)\n    ) external pure returns (uint);\n\n    function getTradeLiquidationPrice(\n        address trader,\n        uint pairIndex,\n        uint index,\n        uint openPrice, // PRECISION\n        bool long,\n        uint collateral, // 1e18 (DAI)\n        uint leverage\n    ) external view returns (uint); // PRECISION\n\n    function getTradeValue(\n        address trader,\n        uint pairIndex,\n        uint index,\n        bool long,\n        uint collateral, // 1e18 (DAI)\n        uint leverage,\n        int percentProfit, // PRECISION (%)\n        uint closingFee // 1e18 (DAI)\n    ) external returns (uint); // 1e18 (DAI)\n\n    function manager() external view returns (address);\n}\n"
    },
    "contracts/interfaces/PairsStorageInterfaceV6.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface PairsStorageInterfaceV6 {\n    enum FeedCalculation {\n        DEFAULT,\n        INVERT,\n        COMBINE\n    } // FEED 1, 1 / (FEED 1), (FEED 1)/(FEED 2)\n    struct Feed {\n        address feed1;\n        address feed2;\n        FeedCalculation feedCalculation;\n        uint maxDeviationP;\n    } // PRECISION (%)\n\n    function incrementCurrentOrderId() external returns (uint);\n\n    function updateGroupCollateral(uint, uint, bool, bool) external;\n\n    function pairJob(\n        uint\n    ) external returns (string memory, string memory, bytes32, uint);\n\n    function pairFeed(uint) external view returns (Feed memory);\n\n    function pairSpreadP(uint) external view returns (uint);\n\n    function pairMinLeverage(uint) external view returns (uint);\n\n    function pairMaxLeverage(uint) external view returns (uint);\n\n    function groupMaxCollateral(uint) external view returns (uint);\n\n    function groupCollateral(uint, bool) external view returns (uint);\n\n    function guaranteedSlEnabled(uint) external view returns (bool);\n\n    function pairOpenFeeP(uint) external view returns (uint);\n\n    function pairCloseFeeP(uint) external view returns (uint);\n\n    function pairOracleFeeP(uint) external view returns (uint);\n\n    function pairNftLimitOrderFeeP(uint) external view returns (uint);\n\n    function pairReferralFeeP(uint) external view returns (uint);\n\n    function pairMinLevPosWETH(uint) external view returns (uint);\n\n    function pairsCount() external view returns (uint);\n}\n"
    },
    "contracts/interfaces/PausableInterfaceV5.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface PausableInterfaceV5 {\n    function isPaused() external view returns (bool);\n}\n"
    },
    "contracts/interfaces/PoolInterfaceV5.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface PoolInterfaceV5 {\n    function increaseAccTokensPerLp(uint) external;\n}\n"
    },
    "contracts/interfaces/ReferralsInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface ReferralsInterface {\n    function registerPotentialReferrer(\n        address trader,\n        address referral\n    ) external;\n\n    function distributePotentialReward(\n        address trader,\n        uint volumeWETH,\n        uint pairOpenFeeP,\n        uint tokenPriceWETH\n    ) external returns (uint);\n\n    function getPercentOfOpenFeeP(address trader) external view returns (uint);\n\n    function getTraderReferrer(\n        address trader\n    ) external view returns (address referrer);\n}\n"
    },
    "contracts/interfaces/StorageInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./TokenInterface.sol\";\nimport \"./NftInterfaceV5.sol\";\nimport \"./IGToken.sol\";\nimport \"./AggregatorInterfaceV1_4.sol\";\n\ninterface StorageInterface {\n    enum LimitOrder {\n        TP,\n        SL,\n        LIQ,\n        OPEN\n    }\n    struct Trade {\n        address trader;\n        uint pairIndex;\n        uint index;\n        uint initialPosToken; // 1e18\n        uint positionSizeWETH; // 1e18\n        uint openPrice; // PRECISION\n        bool buy;\n        uint leverage;\n        uint tp; // PRECISION\n        uint sl; // PRECISION\n    }\n    struct TradeInfo {\n        uint tokenId;\n        uint tokenPriceWETH; // PRECISION\n        uint openInterestWETH; // 1e18\n        uint tpLastUpdated;\n        uint slLastUpdated;\n        bool beingMarketClosed;\n    }\n    struct OpenLimitOrder {\n        address trader;\n        uint pairIndex;\n        uint index;\n        uint positionSize; // 1e18 (WETH or GFARM2)\n        uint spreadReductionP;\n        bool buy;\n        uint leverage;\n        uint tp; // PRECISION (%)\n        uint sl; // PRECISION (%)\n        uint minPrice; // PRECISION\n        uint maxPrice; // PRECISION\n        uint block;\n        uint tokenId; // index in supportedTokens\n    }\n    struct PendingMarketOrder {\n        Trade trade;\n        uint block;\n        uint wantedPrice; // PRECISION\n        uint slippageP; // PRECISION (%)\n        uint spreadReductionP;\n        uint tokenId; // index in supportedTokens\n    }\n    struct PendingNftOrder {\n        address nftHolder;\n        uint nftId;\n        address trader;\n        uint pairIndex;\n        uint index;\n        LimitOrder orderType;\n    }\n\n    function PRECISION() external pure returns (uint);\n\n    function gov() external view returns (address);\n\n    function dev() external view returns (address);\n\n    function WETH() external view returns (TokenInterface);\n\n    function token() external view returns (TokenInterface);\n\n    function linkErc677() external view returns (TokenInterface);\n\n    function priceAggregator() external view returns (AggregatorInterfaceV1_4);\n\n    function vault() external view returns (IGToken);\n\n    function trading() external view returns (address);\n\n    function callbacks() external view returns (address);\n\n    function handleTokens(address, uint, bool) external;\n\n    function transferWETH(address, address, uint) external;\n\n    function transferLinkToAggregator(address, uint, uint) external;\n\n    function unregisterTrade(address, uint, uint) external;\n\n    function unregisterPendingMarketOrder(uint, bool) external;\n\n    function unregisterOpenLimitOrder(address, uint, uint) external;\n\n    function hasOpenLimitOrder(\n        address,\n        uint,\n        uint\n    ) external view returns (bool);\n\n    function storePendingMarketOrder(\n        PendingMarketOrder memory,\n        uint,\n        bool\n    ) external;\n\n    function openTrades(\n        address,\n        uint,\n        uint\n    ) external view returns (Trade memory);\n\n    function openTradesInfo(\n        address,\n        uint,\n        uint\n    ) external view returns (TradeInfo memory);\n\n    function updateSl(address, uint, uint, uint) external;\n\n    function updateTp(address, uint, uint, uint) external;\n\n    function getOpenLimitOrder(\n        address,\n        uint,\n        uint\n    ) external view returns (OpenLimitOrder memory);\n\n    function spreadReductionsP(uint) external view returns (uint);\n\n    function storeOpenLimitOrder(OpenLimitOrder memory) external;\n\n    function reqID_pendingMarketOrder(\n        uint\n    ) external view returns (PendingMarketOrder memory);\n\n    function storePendingNftOrder(PendingNftOrder memory, uint) external;\n\n    function updateOpenLimitOrder(OpenLimitOrder calldata) external;\n\n    function firstEmptyTradeIndex(address, uint) external view returns (uint);\n\n    function firstEmptyOpenLimitIndex(\n        address,\n        uint\n    ) external view returns (uint);\n\n    function increaseNftRewards(uint, uint) external;\n\n    function nftSuccessTimelock() external view returns (uint);\n\n    function reqID_pendingNftOrder(\n        uint\n    ) external view returns (PendingNftOrder memory);\n\n    function updateTrade(Trade memory) external;\n\n    function nftLastSuccess(uint) external view returns (uint);\n\n    function unregisterPendingNftOrder(uint) external;\n\n    function handleDevGovFees(uint, uint, bool, bool) external returns (uint);\n\n    function distributeLpRewards(uint) external;\n\n    function storeTrade(Trade memory, TradeInfo memory) external;\n\n    function openLimitOrdersCount(address, uint) external view returns (uint);\n\n    function openTradesCount(address, uint) external view returns (uint);\n\n    function pendingMarketOpenCount(address, uint) external view returns (uint);\n\n    function pendingMarketCloseCount(\n        address,\n        uint\n    ) external view returns (uint);\n\n    function maxTradesPerPair() external view returns (uint);\n\n    function pendingOrderIdsCount(address) external view returns (uint);\n\n    function maxPendingMarketOrders() external view returns (uint);\n\n    function openInterestWETH(uint, uint) external view returns (uint);\n\n    function getPendingOrderIds(address) external view returns (uint[] memory);\n\n    function nfts(uint) external view returns (NftInterfaceV5);\n\n    function fakeBlockNumber() external view returns (uint); // Testing\n\n    function getGov() external view returns (address); // checking \n}\n"
    },
    "contracts/interfaces/TokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface TokenInterface {\n    function burn(address, uint256) external;\n\n    function mint(address, uint256) external;\n\n    function transfer(address, uint256) external returns (bool);\n\n    function transferFrom(address, address, uint256) external returns (bool);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function hasRole(bytes32, address) external view returns (bool);\n\n    function approve(address, uint256) external returns (bool);\n\n    function allowance(address, address) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/TradingCallbacksInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface TradingCallbacksInterface {\n    enum TradeType {\n        MARKET,\n        LIMIT\n    }\n    struct SimplifiedTradeId {\n        address trader;\n        uint pairIndex;\n        uint index;\n        TradeType tradeType;\n    }\n    struct LastUpdated {\n        uint32 tp;\n        uint32 sl;\n        uint32 limit;\n        uint32 created;\n    }\n    struct TradeData {\n        uint40 maxSlippageP; // 1e10 (%)\n        uint216 _placeholder; // for potential future data\n    }\n\n    function tradeLastUpdated(\n        address,\n        uint,\n        uint,\n        TradeType\n    ) external view returns (LastUpdated memory);\n\n    function setTradeLastUpdated(\n        SimplifiedTradeId calldata,\n        LastUpdated memory\n    ) external;\n\n    function setTradeData(\n        SimplifiedTradeId calldata,\n        TradeData memory\n    ) external;\n\n    function canExecuteTimeout() external view returns (uint);\n\n    function pairMaxLeverage(uint) external view returns (uint);\n}\n"
    },
    "contracts/interfaces/UniswapRouterInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface UniswapRouterInterface {\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n}\n"
    },
    "contracts/interfaces/VaultInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface VaultInterface {\n    function sendWETHToTrader(address, uint) external;\n\n    function receiveWETHFromTrader(address, uint, uint) external;\n\n    function currentBalanceWETH() external view returns (uint);\n\n    function distributeRewardWETH(uint) external;\n}\n"
    },
    "contracts/libraries/ChainUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../interfaces/IArbSys.sol\";\n\nlibrary ChainUtils {\n    uint256 public constant ARBITRUM_MAINNET = 42161;\n    uint256 public constant ARBITRUM_GOERLI = 421613;\n    IArbSys public constant ARB_SYS = IArbSys(address(100));\n\n    function getBlockNumber() internal view returns (uint) {\n        if (\n            block.chainid == ARBITRUM_MAINNET ||\n            block.chainid == ARBITRUM_GOERLI\n        ) {\n            return ARB_SYS.arbBlockNumber();\n        }\n\n        return block.number;\n    }\n\n    function getUint48BlockNumber(\n        uint blockNumber\n    ) internal pure returns (uint48) {\n        require(blockNumber <= type(uint48).max, \"OVERFLOW\");\n        return uint48(blockNumber);\n    }\n}\n"
    },
    "contracts/libraries/PackingUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nlibrary PackingUtils {\n    function pack(\n        uint256[] memory values,\n        uint256[] memory bitLengths\n    ) external pure returns (uint256 packed) {\n        require(\n            values.length == bitLengths.length,\n            \"Mismatch in the lengths of values and bitLengths arrays\"\n        );\n\n        uint256 currentShift;\n\n        for (uint256 i; i < values.length; i++) {\n            require(\n                currentShift + bitLengths[i] <= 256,\n                \"Packed value exceeds 256 bits\"\n            );\n\n            uint256 maxValue = (1 << bitLengths[i]) - 1;\n            require(\n                values[i] <= maxValue,\n                \"Value too large for specified bit length\"\n            );\n\n            uint256 maskedValue = values[i] & maxValue;\n            packed |= maskedValue << currentShift;\n            currentShift += bitLengths[i];\n        }\n    }\n\n    function unpack(\n        uint256 packed,\n        uint256[] memory bitLengths\n    ) external pure returns (uint256[] memory values) {\n        values = new uint256[](bitLengths.length);\n\n        uint256 currentShift;\n        for (uint256 i; i < bitLengths.length; i++) {\n            require(\n                currentShift + bitLengths[i] <= 256,\n                \"Unpacked value exceeds 256 bits\"\n            );\n\n            uint256 maxValue = (1 << bitLengths[i]) - 1;\n            uint256 mask = maxValue << currentShift;\n            values[i] = (packed & mask) >> currentShift;\n\n            currentShift += bitLengths[i];\n        }\n    }\n\n    function unpack256To64(\n        uint256 packed\n    ) external pure returns (uint64 a, uint64 b, uint64 c, uint64 d) {\n        a = uint64(packed);\n        b = uint64(packed >> 64);\n        c = uint64(packed >> 128);\n        d = uint64(packed >> 192);\n    }\n\n    // Function-specific unpacking utils\n    function unpackExecuteNftOrder(\n        uint256 packed\n    )\n        external\n        pure\n        returns (\n            uint256 a,\n            address b,\n            uint256 c,\n            uint256 d,\n            uint256 e,\n            uint256 f\n        )\n    {\n        a = packed & 0xFF; // 8 bits\n        b = address(uint160(packed >> 8)); // 160 bits\n        c = (packed >> 168) & 0xFFFF; // 16 bits\n        d = (packed >> 184) & 0xFFFF; // 16 bits\n        e = (packed >> 200) & 0xFFFF; // 16 bits\n        f = (packed >> 216) & 0xFFFF; // 16 bits\n    }\n}\n"
    },
    "contracts/libraries/TradeUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../interfaces/StorageInterface.sol\";\nimport \"../interfaces/TradingCallbacksInterface.sol\";\n\nlibrary TradeUtils {\n    function _getTradeLastUpdated(\n        address _callbacks,\n        address trader,\n        uint pairIndex,\n        uint index,\n        TradingCallbacksInterface.TradeType _type\n    )\n        internal\n        view\n        returns (\n            TradingCallbacksInterface,\n            TradingCallbacksInterface.LastUpdated memory,\n            TradingCallbacksInterface.SimplifiedTradeId memory\n        )\n    {\n        TradingCallbacksInterface callbacks = TradingCallbacksInterface(\n            _callbacks\n        );\n        TradingCallbacksInterface.LastUpdated memory l = callbacks\n            .tradeLastUpdated(trader, pairIndex, index, _type);\n\n        return (\n            callbacks,\n            l,\n            TradingCallbacksInterface.SimplifiedTradeId(\n                trader,\n                pairIndex,\n                index,\n                _type\n            )\n        );\n    }\n\n    function setTradeLastUpdated(\n        address _callbacks,\n        address trader,\n        uint pairIndex,\n        uint index,\n        TradingCallbacksInterface.TradeType _type,\n        uint blockNumber\n    ) external {\n        uint32 b = uint32(blockNumber);\n        TradingCallbacksInterface callbacks = TradingCallbacksInterface(\n            _callbacks\n        );\n        callbacks.setTradeLastUpdated(\n            TradingCallbacksInterface.SimplifiedTradeId(\n                trader,\n                pairIndex,\n                index,\n                _type\n            ),\n            TradingCallbacksInterface.LastUpdated(b, b, b, b)\n        );\n    }\n\n    function setSlLastUpdated(\n        address _callbacks,\n        address trader,\n        uint pairIndex,\n        uint index,\n        TradingCallbacksInterface.TradeType _type,\n        uint blockNumber\n    ) external {\n        (\n            TradingCallbacksInterface callbacks,\n            TradingCallbacksInterface.LastUpdated memory l,\n            TradingCallbacksInterface.SimplifiedTradeId memory id\n        ) = _getTradeLastUpdated(_callbacks, trader, pairIndex, index, _type);\n\n        l.sl = uint32(blockNumber);\n        callbacks.setTradeLastUpdated(id, l);\n    }\n\n    function setTpLastUpdated(\n        address _callbacks,\n        address trader,\n        uint pairIndex,\n        uint index,\n        TradingCallbacksInterface.TradeType _type,\n        uint blockNumber\n    ) external {\n        (\n            TradingCallbacksInterface callbacks,\n            TradingCallbacksInterface.LastUpdated memory l,\n            TradingCallbacksInterface.SimplifiedTradeId memory id\n        ) = _getTradeLastUpdated(_callbacks, trader, pairIndex, index, _type);\n\n        l.tp = uint32(blockNumber);\n        callbacks.setTradeLastUpdated(id, l);\n    }\n\n    function isTpInTimeout(\n        address _callbacks,\n        TradingCallbacksInterface.SimplifiedTradeId memory id,\n        uint currentBlock\n    ) external view returns (bool) {\n        (\n            TradingCallbacksInterface callbacks,\n            TradingCallbacksInterface.LastUpdated memory l,\n\n        ) = _getTradeLastUpdated(\n                _callbacks,\n                id.trader,\n                id.pairIndex,\n                id.index,\n                id.tradeType\n            );\n\n        return currentBlock < uint256(l.tp) + callbacks.canExecuteTimeout();\n    }\n\n    function isSlInTimeout(\n        address _callbacks,\n        TradingCallbacksInterface.SimplifiedTradeId memory id,\n        uint currentBlock\n    ) external view returns (bool) {\n        (\n            TradingCallbacksInterface callbacks,\n            TradingCallbacksInterface.LastUpdated memory l,\n\n        ) = _getTradeLastUpdated(\n                _callbacks,\n                id.trader,\n                id.pairIndex,\n                id.index,\n                id.tradeType\n            );\n\n        return currentBlock < uint256(l.sl) + callbacks.canExecuteTimeout();\n    }\n\n    function isLimitInTimeout(\n        address _callbacks,\n        TradingCallbacksInterface.SimplifiedTradeId memory id,\n        uint currentBlock\n    ) external view returns (bool) {\n        (\n            TradingCallbacksInterface callbacks,\n            TradingCallbacksInterface.LastUpdated memory l,\n\n        ) = _getTradeLastUpdated(\n                _callbacks,\n                id.trader,\n                id.pairIndex,\n                id.index,\n                id.tradeType\n            );\n\n        return currentBlock < uint256(l.limit) + callbacks.canExecuteTimeout();\n    }\n\n    function setTradeData(\n        address _callbacks,\n        address trader,\n        uint pairIndex,\n        uint index,\n        TradingCallbacksInterface.TradeType _type,\n        uint maxSlippageP\n    ) external {\n        require(maxSlippageP <= type(uint40).max, \"OVERFLOW\");\n        TradingCallbacksInterface callbacks = TradingCallbacksInterface(\n            _callbacks\n        );\n        callbacks.setTradeData(\n            TradingCallbacksInterface.SimplifiedTradeId(\n                trader,\n                pairIndex,\n                index,\n                _type\n            ),\n            TradingCallbacksInterface.TradeData(uint40(maxSlippageP), 0)\n        );\n    }\n}\n"
    },
    "contracts/PairsStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./interfaces/UniswapRouterInterface.sol\";\nimport \"./interfaces/TokenInterface.sol\";\nimport \"./interfaces/NftInterfaceV5.sol\";\nimport \"./interfaces/VaultInterface.sol\";\nimport \"./interfaces/PairsStorageInterfaceV6.sol\";\nimport \"./interfaces/StorageInterface.sol\";\nimport \"./interfaces/AggregatorInterfaceV1_1.sol\";\nimport \"./interfaces/NftRewardsInterfaceV6.sol\";\n\ncontract PairsStorage {\n    // Contracts (constant)\n    StorageInterface public storageT;\n\n    // Params (constant)\n    uint constant MIN_LEVERAGE = 2;\n    uint constant MAX_LEVERAGE = 1000;\n\n    // Custom data types\n    enum FeedCalculation {\n        DEFAULT,\n        INVERT,\n        COMBINE\n    }\n    struct Feed {\n        address feed1;\n        address feed2;\n        FeedCalculation feedCalculation;\n        uint maxDeviationP;\n    } // PRECISION (%)\n\n    struct Pair {\n        string from;\n        string to;\n        Feed feed;\n        uint spreadP; // PRECISION\n        uint groupIndex;\n        uint feeIndex;\n    }\n    struct Group {\n        string name;\n        bytes32 job;\n        uint minLeverage;\n        uint maxLeverage;\n        uint maxCollateralP; // % (of WETH vault current balance)\n    }\n    struct Fee {\n        string name;\n        uint openFeeP; // PRECISION (% of leveraged pos)\n        uint closeFeeP; // PRECISION (% of leveraged pos)\n        uint oracleFeeP; // PRECISION (% of leveraged pos)\n        uint nftLimitOrderFeeP; // PRECISION (% of leveraged pos)\n        uint referralFeeP; // PRECISION (% of leveraged pos)\n        uint minLevPosWETH; // 1e18 (collateral x leverage, useful for min fee)\n    }\n\n    // State\n    uint public currentOrderId;\n\n    uint public pairsCount;\n    uint public groupsCount;\n    uint public feesCount;\n\n    mapping(uint => Pair) public pairs;\n    mapping(uint => Group) public groups;\n    mapping(uint => Fee) public fees;\n\n    mapping(string => mapping(string => bool)) public isPairListed;\n\n    mapping(uint => uint[2]) public groupsCollaterals; // (long, short)\n\n    // Events\n    event PairAdded(uint index, string from, string to);\n    event PairUpdated(uint index);\n\n    event GroupAdded(uint index, string name);\n    event GroupUpdated(uint index);\n\n    event FeeAdded(uint index, string name);\n    event FeeUpdated(uint index);\n\n    constructor(uint _currentOrderId, address _storage) {\n        require(_currentOrderId > 0, \"ORDER_ID_0\");\n        currentOrderId = _currentOrderId;\n        storageT = StorageInterface(_storage);\n    }\n\n    // Modifiers\n    modifier onlyGov() {\n        require(msg.sender == storageT.gov(), \"GOV_ONLY\"); //// TODO check error function returned an unexpected amount of data\n        _;\n    }\n\n    modifier groupListed(uint _groupIndex) {\n        require(groups[_groupIndex].minLeverage > 0, \"GROUP_NOT_LISTED\");\n        _;\n    }\n    modifier feeListed(uint _feeIndex) {\n        require(fees[_feeIndex].openFeeP > 0, \"FEE_NOT_LISTED\");\n        _;\n    }\n\n    modifier feedOk(Feed calldata _feed) {\n        require(\n            _feed.maxDeviationP > 0 && _feed.feed1 != address(0),\n            \"WRONG_FEED\"\n        );\n        require(\n            _feed.feedCalculation != FeedCalculation.COMBINE ||\n                _feed.feed2 != address(0),\n            \"FEED_2_MISSING\"\n        );\n        _;\n    }\n    modifier groupOk(Group calldata _group) {\n        require(_group.job != bytes32(0), \"JOB_EMPTY\");\n        require(\n            _group.minLeverage >= MIN_LEVERAGE &&\n                _group.maxLeverage <= MAX_LEVERAGE &&\n                _group.minLeverage < _group.maxLeverage,\n            \"WRONG_LEVERAGES\"\n        );\n        _;\n    }\n    modifier feeOk(Fee calldata _fee) {\n        require(\n            _fee.openFeeP > 0 &&\n                _fee.closeFeeP > 0 &&\n                _fee.oracleFeeP > 0 &&\n                _fee.nftLimitOrderFeeP > 0 &&\n                _fee.referralFeeP > 0 &&\n                _fee.minLevPosWETH > 0,\n            \"WRONG_FEES\"\n        );\n        _;\n    }\n\n    // Manage pairs\n    function addPair(\n        Pair calldata _pair\n    )\n        public\n        onlyGov // feedOk(_pair.feed)\n    // groupListed(_pair.groupIndex) /// TODO : uncomment\n    // feeListed(_pair.feeIndex)\n    {\n        require(!isPairListed[_pair.from][_pair.to], \"PAIR_ALREADY_LISTED\");\n        pairs[pairsCount] = _pair;\n        isPairListed[_pair.from][_pair.to] = true;\n\n        emit PairAdded(pairsCount++, _pair.from, _pair.to);\n    }\n\n    function addPairs(Pair[] calldata _pairs) external {\n        for (uint i = 0; i < _pairs.length; i++) {\n            addPair(_pairs[i]);\n        }\n    }\n\n    function updatePair(\n        uint _pairIndex,\n        Pair calldata _pair\n    ) external onlyGov feedOk(_pair.feed) feeListed(_pair.feeIndex) {\n        Pair storage p = pairs[_pairIndex];\n        require(isPairListed[p.from][p.to], \"PAIR_NOT_LISTED\");\n\n        p.feed = _pair.feed;\n        p.spreadP = _pair.spreadP;\n        p.feeIndex = _pair.feeIndex;\n\n        emit PairUpdated(_pairIndex);\n    }\n\n    // Manage groups\n    function addGroup(Group calldata _group) external onlyGov groupOk(_group) {\n        groups[groupsCount] = _group;\n        emit GroupAdded(groupsCount++, _group.name);\n    }\n\n    function updateGroup(\n        uint _id,\n        Group calldata _group\n    ) external onlyGov groupListed(_id) groupOk(_group) {\n        groups[_id] = _group;\n        emit GroupUpdated(_id);\n    }\n\n    // Manage fees\n    function addFee(Fee calldata _fee) external onlyGov feeOk(_fee) {\n        fees[feesCount] = _fee;\n        emit FeeAdded(feesCount++, _fee.name);\n    }\n\n    function updateFee(\n        uint _id,\n        Fee calldata _fee\n    ) external onlyGov feeListed(_id) feeOk(_fee) {\n        fees[_id] = _fee;\n        emit FeeUpdated(_id);\n    }\n\n    // Update collateral open exposure for a group (callbacks)\n    function updateGroupCollateral(\n        uint _pairIndex,\n        uint _amount,\n        bool _long,\n        bool _increase\n    ) external {\n        require(msg.sender == storageT.callbacks(), \"CALLBACKS_ONLY\");\n\n        uint[2] storage collateralOpen = groupsCollaterals[\n            pairs[_pairIndex].groupIndex\n        ];\n        uint index = _long ? 0 : 1;\n\n        if (_increase) {\n            collateralOpen[index] += _amount;\n        } else {\n            collateralOpen[index] = collateralOpen[index] > _amount\n                ? collateralOpen[index] - _amount\n                : 0;\n        }\n    }\n\n    // Fetch relevant info for order (aggregator)\n    function pairJob(\n        uint _pairIndex\n    ) external returns (string memory, string memory, bytes32, uint) {\n        require(\n            msg.sender == address(storageT.priceAggregator()),\n            \"AGGREGATOR_ONLY\"\n        );\n\n        Pair memory p = pairs[_pairIndex];\n        require(isPairListed[p.from][p.to], \"PAIR_NOT_LISTED\");\n\n        return (p.from, p.to, groups[p.groupIndex].job, currentOrderId++);\n    }\n\n    // Getters (pairs & groups)\n    function pairFeed(uint _pairIndex) external view returns (Feed memory) {\n        return pairs[_pairIndex].feed;\n    }\n\n    function pairSpreadP(uint _pairIndex) external view returns (uint) {\n        return pairs[_pairIndex].spreadP;\n    }\n\n    function pairMinLeverage(uint _pairIndex) external view returns (uint) {\n        return groups[pairs[_pairIndex].groupIndex].minLeverage;\n    }\n\n    function pairMaxLeverage(uint _pairIndex) external view returns (uint) {\n        return groups[pairs[_pairIndex].groupIndex].maxLeverage;\n    }\n\n    function groupMaxCollateral(uint _pairIndex) external view returns (uint) {\n        return\n            (groups[pairs[_pairIndex].groupIndex].maxCollateralP *\n                storageT.vault().currentBalanceWETH()) / 100;\n    }\n\n    function groupCollateral(\n        uint _pairIndex,\n        bool _long\n    ) external view returns (uint) {\n        return groupsCollaterals[pairs[_pairIndex].groupIndex][_long ? 0 : 1];\n    }\n\n    function guaranteedSlEnabled(uint _pairIndex) external view returns (bool) {\n        return pairs[_pairIndex].groupIndex == 0; // crypto only\n    }\n\n    // Getters (fees)\n    function pairOpenFeeP(uint _pairIndex) external view returns (uint) {\n        return fees[pairs[_pairIndex].feeIndex].openFeeP;\n    }\n\n    function pairCloseFeeP(uint _pairIndex) external view returns (uint) {\n        return fees[pairs[_pairIndex].feeIndex].closeFeeP;\n    }\n\n    function pairOracleFeeP(uint _pairIndex) external view returns (uint) {\n        return fees[pairs[_pairIndex].feeIndex].oracleFeeP;\n    }\n\n    function pairNftLimitOrderFeeP(\n        uint _pairIndex\n    ) external view returns (uint) {\n        return fees[pairs[_pairIndex].feeIndex].nftLimitOrderFeeP;\n    }\n\n    function pairReferralFeeP(uint _pairIndex) external view returns (uint) {\n        return fees[pairs[_pairIndex].feeIndex].referralFeeP;\n    }\n\n    function pairMinLevPosWETH(uint _pairIndex) external view returns (uint) {\n        return fees[pairs[_pairIndex].feeIndex].minLevPosWETH;\n    }\n\n    // Getters (backend)\n    function pairsBackend(\n        uint _index\n    ) external view returns (Pair memory, Group memory, Fee memory) {\n        Pair memory p = pairs[_index];\n        return (p, groups[p.groupIndex], fees[p.feeIndex]);\n    }\n}\n"
    },
    "contracts/Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./interfaces/StorageInterface.sol\";\nimport \"./interfaces/AggregatorInterfaceV1.sol\";\nimport \"./interfaces/PoolInterfaceV5.sol\";\nimport \"./interfaces/NftInterfaceV5.sol\";\nimport \"./interfaces/PausableInterfaceV5.sol\";\n\ncontract Storage {\n    // Constants\n    uint public constant PRECISION = 1e10;\n    bytes32 public constant MINTER_ROLE =\n        0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6;\n    TokenInterface public WETH;\n    TokenInterface public constant linkErc677 =\n        TokenInterface(0xb0897686c545045aFc77CF20eC7A532E3120E0F1);\n\n    // Contracts (updatable)\n    AggregatorInterfaceV1 public priceAggregator;\n    PoolInterfaceV5 public pool;\n    PausableInterfaceV5 public trading;\n    PausableInterfaceV5 public callbacks;\n    TokenInterface public token =\n        TokenInterface(0x7075cAB6bCCA06613e2d071bd918D1a0241379E2);\n    NftInterfaceV5[5] public nfts = [\n        NftInterfaceV5(0xF9A4c522E327935BD1F5a338c121E14e4cc1f898),\n        NftInterfaceV5(0x77cd42B925e1A82f41d852D6BE727CFc88fddBbC),\n        NftInterfaceV5(0x3378AD81D09DE23725Ee9B9270635c97Ed601921),\n        NftInterfaceV5(0x02e2c5825C1a3b69C0417706DbE1327C2Af3e6C2),\n        NftInterfaceV5(0x2D266A94469d05C9e06D52A4D0d9C23b157767c2)\n    ];\n    address public vault;\n    address public tokenWETHRouter;\n\n    // Trading variables\n    uint public maxTradesPerPair = 3;\n    uint public maxTradesPerBlock = 5;\n    uint public maxPendingMarketOrders = 5;\n    uint public maxGainP = 900; // %\n    uint public maxSlP = 80; // %\n    uint public defaultLeverageUnlocked = 50; // x\n    uint public nftSuccessTimelock = 50; // 50 blocks\n    uint[5] public spreadReductionsP = [15, 20, 25, 30, 35]; // %\n\n    // Gov & dev addresses (updatable)\n    address public gov; //TODO need to change to our\n    address public dev; //TODO need to change to our\n\n    // Gov & dev fees\n    uint public devFeesToken; // 1e18\n    uint public devFeesWETH; // 1e18\n    uint public govFeesToken; // 1e18\n    uint public govFeesWETH; // 1e18\n\n    // Stats\n    uint public tokensBurned; // 1e18\n    uint public tokensMinted; // 1e18\n    uint public nftRewards; // 1e18\n\n    // Enums\n    enum LimitOrder {\n        TP,\n        SL,\n        LIQ,\n        OPEN\n    }\n\n    // Structs\n    struct Trader {\n        uint leverageUnlocked;\n        address referral;\n        uint referralRewardsTotal; // 1e18\n    }\n    struct Trade {\n        address trader;\n        uint pairIndex;\n        uint index;\n        uint initialPosToken; // 1e18\n        uint positionSizeWETH; // 1e18\n        uint openPrice; // PRECISION\n        bool buy;\n        uint leverage;\n        uint tp; // PRECISION\n        uint sl; // PRECISION\n    }\n    struct TradeInfo {\n        uint tokenId;\n        uint tokenPriceWETH; // PRECISION\n        uint openInterestWETH; // 1e18\n        uint tpLastUpdated;\n        uint slLastUpdated;\n        bool beingMarketClosed;\n    }\n    struct OpenLimitOrder {\n        address trader;\n        uint pairIndex;\n        uint index;\n        uint positionSize; // 1e18 (WETH or GFARM2)\n        uint spreadReductionP;\n        bool buy;\n        uint leverage;\n        uint tp; // PRECISION (%)\n        uint sl; // PRECISION (%)\n        uint minPrice; // PRECISION\n        uint maxPrice; // PRECISION\n        uint block;\n        uint tokenId; // index in supportedTokens\n    }\n    struct PendingMarketOrder {\n        Trade trade;\n        uint block;\n        uint wantedPrice; // PRECISION\n        uint slippageP; // PRECISION (%)\n        uint spreadReductionP;\n        uint tokenId; // index in supportedTokens\n    }\n    struct PendingNftOrder {\n        address nftHolder;\n        uint nftId;\n        address trader;\n        uint pairIndex;\n        uint index;\n        LimitOrder orderType;\n    }\n\n    // Supported tokens to open trades with\n    address[] public supportedTokens;\n\n    // User info mapping\n    mapping(address => Trader) public traders;\n\n    // Trades mappings\n    mapping(address => mapping(uint => mapping(uint => Trade)))\n        public openTrades;\n    mapping(address => mapping(uint => mapping(uint => TradeInfo)))\n        public openTradesInfo;\n    mapping(address => mapping(uint => uint)) public openTradesCount;\n\n    // Limit orders mappings\n    mapping(address => mapping(uint => mapping(uint => uint)))\n        public openLimitOrderIds;\n    mapping(address => mapping(uint => uint)) public openLimitOrdersCount;\n    OpenLimitOrder[] public openLimitOrders;\n\n    // Pending orders mappings\n    mapping(uint => PendingMarketOrder) public reqID_pendingMarketOrder;\n    mapping(uint => PendingNftOrder) public reqID_pendingNftOrder;\n    mapping(address => uint[]) public pendingOrderIds;\n    mapping(address => mapping(uint => uint)) public pendingMarketOpenCount;\n    mapping(address => mapping(uint => uint)) public pendingMarketCloseCount;\n\n    // List of open trades & limit orders\n    mapping(uint => address[]) public pairTraders;\n    mapping(address => mapping(uint => uint)) public pairTradersId;\n\n    // Current and max open interests for each pair\n    mapping(uint => uint[3]) public openInterestWETH; // 1e18 [long,short,max]\n\n    // Restrictions & Timelocks\n    mapping(uint => uint) public tradesPerBlock;\n    mapping(uint => uint) public nftLastSuccess;\n\n    // List of allowed contracts => can update storage + mint/burn tokens\n    mapping(address => bool) public isTradingContract;\n\n    // Events\n    event SupportedTokenAdded(address a);\n    event TradingContractAdded(address a);\n    event TradingContractRemoved(address a);\n    event AddressUpdated(string name, address a);\n    event NftsUpdated(NftInterfaceV5[5] nfts);\n    event NumberUpdated(string name, uint value);\n    event NumberUpdatedPair(string name, uint pairIndex, uint value);\n    event SpreadReductionsUpdated(uint[5]);\n\n    constructor(address _WETH, address _gov, address _dev) {\n        WETH = TokenInterface(_WETH);\n        gov = _gov;\n        dev = _dev;\n    }\n\n    // Modifiers\n    modifier onlyGov() {\n        require(msg.sender == gov);\n        _;\n    }\n    modifier onlyTrading() {\n        require(\n            isTradingContract[msg.sender]\n            // &&\n            //     token.hasRole(MINTER_ROLE, msg.sender)\n        );\n        _;\n    }\n\n    // Manage addresses\n    function setGov(address _gov) external onlyGov {\n        require(_gov != address(0));\n        gov = _gov;\n        emit AddressUpdated(\"gov\", _gov);\n    }\n\n    function setDev(address _dev) external onlyGov {\n        require(_dev != address(0));\n        dev = _dev;\n        emit AddressUpdated(\"dev\", _dev);\n    }\n\n    function updateToken(TokenInterface _newToken) external onlyGov {\n        require(trading.isPaused() && callbacks.isPaused(), \"NOT_PAUSED\");\n        require(address(_newToken) != address(0));\n        token = _newToken;\n        emit AddressUpdated(\"token\", address(_newToken));\n    }\n\n    function updateNfts(NftInterfaceV5[5] memory _nfts) external onlyGov {\n        require(address(_nfts[0]) != address(0));\n        nfts = _nfts;\n        emit NftsUpdated(_nfts);\n    }\n\n    // Trading + callbacks contracts\n    function addTradingContract(address _trading) external onlyGov {\n        // require(token.hasRole(MINTER_ROLE, _trading), \"NOT_MINTER\"); /// TODO : need to have a gtoken type token of our own\n        require(_trading != address(0));\n        isTradingContract[_trading] = true;\n        emit TradingContractAdded(_trading);\n    }\n\n    function removeTradingContract(address _trading) external onlyGov {\n        require(_trading != address(0));\n        isTradingContract[_trading] = false;\n        emit TradingContractRemoved(_trading);\n    }\n\n    function addSupportedToken(address _token) external onlyGov {\n        require(_token != address(0));\n        supportedTokens.push(_token);\n        emit SupportedTokenAdded(_token);\n    }\n\n    function setPriceAggregator(address _aggregator) external onlyGov {\n        require(_aggregator != address(0));\n        priceAggregator = AggregatorInterfaceV1(_aggregator);\n        emit AddressUpdated(\"priceAggregator\", _aggregator);\n    }\n\n    function setPool(address _pool) external onlyGov {\n        require(_pool != address(0));\n        pool = PoolInterfaceV5(_pool);\n        emit AddressUpdated(\"pool\", _pool);\n    }\n\n    function setVault(address _vault) external onlyGov {\n        require(_vault != address(0));\n        vault = _vault;\n        emit AddressUpdated(\"vault\", _vault);\n    }\n\n    function setTrading(address _trading) external onlyGov {\n        require(_trading != address(0));\n        trading = PausableInterfaceV5(_trading);\n        emit AddressUpdated(\"trading\", _trading);\n    }\n\n    function setCallbacks(address _callbacks) external onlyGov {\n        require(_callbacks != address(0));\n        callbacks = PausableInterfaceV5(_callbacks);\n        emit AddressUpdated(\"callbacks\", _callbacks);\n    }\n\n    function setTokenWETHRouter(address _tokenWETHRouter) external onlyGov {\n        require(_tokenWETHRouter != address(0));\n        tokenWETHRouter = _tokenWETHRouter;\n        emit AddressUpdated(\"tokenWETHRouter\", _tokenWETHRouter);\n    }\n\n    // Manage trading variables\n    function setMaxTradesPerBlock(uint _maxTradesPerBlock) external onlyGov {\n        require(_maxTradesPerBlock > 0);\n        maxTradesPerBlock = _maxTradesPerBlock;\n        emit NumberUpdated(\"maxTradesPerBlock\", _maxTradesPerBlock);\n    }\n\n    function setMaxTradesPerPair(uint _maxTradesPerPair) external onlyGov {\n        require(_maxTradesPerPair > 0);\n        maxTradesPerPair = _maxTradesPerPair;\n        emit NumberUpdated(\"maxTradesPerPair\", _maxTradesPerPair);\n    }\n\n    function setMaxPendingMarketOrders(\n        uint _maxPendingMarketOrders\n    ) external onlyGov {\n        require(_maxPendingMarketOrders > 0);\n        maxPendingMarketOrders = _maxPendingMarketOrders;\n        emit NumberUpdated(\"maxPendingMarketOrders\", _maxPendingMarketOrders);\n    }\n\n    function setMaxGainP(uint _max) external onlyGov {\n        require(_max >= 300);\n        maxGainP = _max;\n        emit NumberUpdated(\"maxGainP\", _max);\n    }\n\n    function setDefaultLeverageUnlocked(uint _lev) external onlyGov {\n        require(_lev > 0);\n        defaultLeverageUnlocked = _lev;\n        emit NumberUpdated(\"defaultLeverageUnlocked\", _lev);\n    }\n\n    function setMaxSlP(uint _max) external onlyGov {\n        require(_max >= 50);\n        maxSlP = _max;\n        emit NumberUpdated(\"maxSlP\", _max);\n    }\n\n    function setNftSuccessTimelock(uint _blocks) external onlyGov {\n        nftSuccessTimelock = _blocks;\n        emit NumberUpdated(\"nftSuccessTimelock\", _blocks);\n    }\n\n    function setSpreadReductionsP(uint[5] calldata _r) external onlyGov {\n        require(\n            _r[0] > 0 &&\n                _r[1] > _r[0] &&\n                _r[2] > _r[1] &&\n                _r[3] > _r[2] &&\n                _r[4] > _r[3]\n        );\n        spreadReductionsP = _r;\n        emit SpreadReductionsUpdated(_r);\n    }\n\n    function setMaxOpenInterestWETH(\n        uint _pairIndex,\n        uint _newMaxOpenInterest\n    ) external onlyGov {\n        // Can set max open interest to 0 to pause trading on this pair only\n        openInterestWETH[_pairIndex][2] = _newMaxOpenInterest;\n        emit NumberUpdatedPair(\n            \"maxOpenInterestWETH\",\n            _pairIndex,\n            _newMaxOpenInterest\n        );\n    }\n\n    // Manage stored trades\n    function storeTrade(\n        Trade memory _trade,\n        TradeInfo memory _tradeInfo\n    ) external onlyTrading {\n        _trade.index = firstEmptyTradeIndex(_trade.trader, _trade.pairIndex);\n        openTrades[_trade.trader][_trade.pairIndex][_trade.index] = _trade;\n\n        openTradesCount[_trade.trader][_trade.pairIndex]++;\n        tradesPerBlock[block.number]++;\n\n        if (openTradesCount[_trade.trader][_trade.pairIndex] == 1) {\n            pairTradersId[_trade.trader][_trade.pairIndex] = pairTraders[\n                _trade.pairIndex\n            ].length;\n            pairTraders[_trade.pairIndex].push(_trade.trader);\n        }\n\n        _tradeInfo.beingMarketClosed = false;\n        openTradesInfo[_trade.trader][_trade.pairIndex][\n            _trade.index\n        ] = _tradeInfo;\n\n        updateOpenInterestWETH(\n            _trade.pairIndex,\n            _tradeInfo.openInterestWETH,\n            true,\n            _trade.buy\n        );\n    }\n\n    function unregisterTrade(\n        address trader,\n        uint pairIndex,\n        uint index\n    ) external onlyTrading {\n        Trade storage t = openTrades[trader][pairIndex][index];\n        TradeInfo storage i = openTradesInfo[trader][pairIndex][index];\n        if (t.leverage == 0) {\n            return;\n        }\n\n        updateOpenInterestWETH(pairIndex, i.openInterestWETH, false, t.buy);\n\n        if (openTradesCount[trader][pairIndex] == 1) {\n            uint _pairTradersId = pairTradersId[trader][pairIndex];\n            address[] storage p = pairTraders[pairIndex];\n\n            p[_pairTradersId] = p[p.length - 1];\n            pairTradersId[p[_pairTradersId]][pairIndex] = _pairTradersId;\n\n            delete pairTradersId[trader][pairIndex];\n            p.pop();\n        }\n\n        delete openTrades[trader][pairIndex][index];\n        delete openTradesInfo[trader][pairIndex][index];\n\n        openTradesCount[trader][pairIndex]--;\n        tradesPerBlock[block.number]++;\n    }\n\n    // Manage pending market orders\n    function storePendingMarketOrder(\n        PendingMarketOrder memory _order,\n        uint _id,\n        bool _open\n    ) external onlyTrading {\n        pendingOrderIds[_order.trade.trader].push(_id);\n\n        reqID_pendingMarketOrder[_id] = _order;\n        reqID_pendingMarketOrder[_id].block = block.number;\n\n        if (_open) {\n            pendingMarketOpenCount[_order.trade.trader][\n                _order.trade.pairIndex\n            ]++;\n        } else {\n            pendingMarketCloseCount[_order.trade.trader][\n                _order.trade.pairIndex\n            ]++;\n            openTradesInfo[_order.trade.trader][_order.trade.pairIndex][\n                _order.trade.index\n            ].beingMarketClosed = true;\n        }\n    }\n\n    function unregisterPendingMarketOrder(\n        uint _id,\n        bool _open\n    ) external onlyTrading {\n        PendingMarketOrder memory _order = reqID_pendingMarketOrder[_id];\n        uint[] storage orderIds = pendingOrderIds[_order.trade.trader];\n\n        for (uint i = 0; i < orderIds.length; i++) {\n            if (orderIds[i] == _id) {\n                if (_open) {\n                    pendingMarketOpenCount[_order.trade.trader][\n                        _order.trade.pairIndex\n                    ]--;\n                } else {\n                    pendingMarketCloseCount[_order.trade.trader][\n                        _order.trade.pairIndex\n                    ]--;\n                    openTradesInfo[_order.trade.trader][_order.trade.pairIndex][\n                        _order.trade.index\n                    ].beingMarketClosed = false;\n                }\n\n                orderIds[i] = orderIds[orderIds.length - 1];\n                orderIds.pop();\n\n                delete reqID_pendingMarketOrder[_id];\n                return;\n            }\n        }\n    }\n\n    // Manage open interest\n    function updateOpenInterestWETH(\n        uint _pairIndex,\n        uint _leveragedPosWETH,\n        bool _open,\n        bool _long\n    ) private {\n        uint index = _long ? 0 : 1;\n        uint[3] storage o = openInterestWETH[_pairIndex];\n        o[index] = _open\n            ? o[index] + _leveragedPosWETH\n            : o[index] - _leveragedPosWETH;\n    }\n\n    // Manage open limit orders\n    function storeOpenLimitOrder(OpenLimitOrder memory o) external onlyTrading {\n        o.index = firstEmptyOpenLimitIndex(o.trader, o.pairIndex);\n        o.block = block.number;\n        openLimitOrders.push(o);\n        openLimitOrderIds[o.trader][o.pairIndex][o.index] =\n            openLimitOrders.length -\n            1;\n        openLimitOrdersCount[o.trader][o.pairIndex]++;\n    }\n\n    function updateOpenLimitOrder(\n        OpenLimitOrder calldata _o\n    ) external onlyTrading {\n        if (!hasOpenLimitOrder(_o.trader, _o.pairIndex, _o.index)) {\n            return;\n        }\n        OpenLimitOrder storage o = openLimitOrders[\n            openLimitOrderIds[_o.trader][_o.pairIndex][_o.index]\n        ];\n        o.positionSize = _o.positionSize;\n        o.buy = _o.buy;\n        o.leverage = _o.leverage;\n        o.tp = _o.tp;\n        o.sl = _o.sl;\n        o.minPrice = _o.minPrice;\n        o.maxPrice = _o.maxPrice;\n        o.block = block.number;\n    }\n\n    function unregisterOpenLimitOrder(\n        address _trader,\n        uint _pairIndex,\n        uint _index\n    ) external onlyTrading {\n        if (!hasOpenLimitOrder(_trader, _pairIndex, _index)) {\n            return;\n        }\n\n        // Copy last order to deleted order => update id of this limit order\n        uint id = openLimitOrderIds[_trader][_pairIndex][_index];\n        openLimitOrders[id] = openLimitOrders[openLimitOrders.length - 1];\n        openLimitOrderIds[openLimitOrders[id].trader][\n            openLimitOrders[id].pairIndex\n        ][openLimitOrders[id].index] = id;\n\n        // Remove\n        delete openLimitOrderIds[_trader][_pairIndex][_index];\n        openLimitOrders.pop();\n\n        openLimitOrdersCount[_trader][_pairIndex]--;\n    }\n\n    // Manage NFT orders\n    function storePendingNftOrder(\n        PendingNftOrder memory _nftOrder,\n        uint _orderId\n    ) external onlyTrading {\n        reqID_pendingNftOrder[_orderId] = _nftOrder;\n    }\n\n    function unregisterPendingNftOrder(uint _order) external onlyTrading {\n        delete reqID_pendingNftOrder[_order];\n    }\n\n    // Manage open trade\n    function updateSl(\n        address _trader,\n        uint _pairIndex,\n        uint _index,\n        uint _newSl\n    ) external onlyTrading {\n        Trade storage t = openTrades[_trader][_pairIndex][_index];\n        TradeInfo storage i = openTradesInfo[_trader][_pairIndex][_index];\n        if (t.leverage == 0) {\n            return;\n        }\n        t.sl = _newSl;\n        i.slLastUpdated = block.number;\n    }\n\n    function updateTp(\n        address _trader,\n        uint _pairIndex,\n        uint _index,\n        uint _newTp\n    ) external onlyTrading {\n        Trade storage t = openTrades[_trader][_pairIndex][_index];\n        TradeInfo storage i = openTradesInfo[_trader][_pairIndex][_index];\n        if (t.leverage == 0) {\n            return;\n        }\n        t.tp = _newTp;\n        i.tpLastUpdated = block.number;\n    }\n\n    function updateTrade(Trade memory _t) external onlyTrading {\n        // useful when partial adding/closing\n        Trade storage t = openTrades[_t.trader][_t.pairIndex][_t.index];\n        if (t.leverage == 0) {\n            return;\n        }\n        t.initialPosToken = _t.initialPosToken;\n        t.positionSizeWETH = _t.positionSizeWETH;\n        t.openPrice = _t.openPrice;\n        t.leverage = _t.leverage;\n    }\n\n    // Manage referrals\n    function storeReferral(\n        address _trader,\n        address _referral\n    ) external onlyTrading {\n        Trader storage trader = traders[_trader];\n        trader.referral = _referral != address(0) &&\n            trader.referral == address(0) &&\n            _referral != _trader\n            ? _referral\n            : trader.referral;\n    }\n\n    function increaseReferralRewards(\n        address _referral,\n        uint _amount\n    ) external onlyTrading {\n        traders[_referral].referralRewardsTotal += _amount;\n    }\n\n    // Manage rewards\n    function distributeLpRewards(uint _amount) external onlyTrading {\n        pool.increaseAccTokensPerLp(_amount);\n    }\n\n    function increaseNftRewards(\n        uint _nftId,\n        uint _amount\n    ) external onlyTrading {\n        nftLastSuccess[_nftId] = block.number;\n        nftRewards += _amount;\n    }\n\n    // Unlock next leverage\n    function setLeverageUnlocked(\n        address _trader,\n        uint _newLeverage\n    ) external onlyTrading {\n        traders[_trader].leverageUnlocked = _newLeverage;\n    }\n\n    // Manage dev & gov fees\n    function handleDevGovFees(\n        uint _pairIndex,\n        uint _leveragedPositionSize,\n        bool _WETH,\n        bool _fullFee\n    ) external onlyTrading returns (uint fee) {\n        fee =\n            (_leveragedPositionSize * priceAggregator.openFeeP(_pairIndex)) /\n            PRECISION /\n            100;\n        if (!_fullFee) {\n            fee /= 2;\n        }\n\n        if (_WETH) {\n            govFeesWETH += fee;\n            devFeesWETH += fee;\n        } else {\n            govFeesToken += fee;\n            devFeesToken += fee;\n        }\n\n        fee *= 2;\n    }\n\n    function claimFees() external onlyGov {\n        token.mint(dev, devFeesToken);\n        token.mint(gov, govFeesToken);\n\n        tokensMinted += devFeesToken + govFeesToken;\n\n        WETH.transfer(gov, govFeesWETH);\n        WETH.transfer(dev, devFeesWETH);\n\n        devFeesToken = 0;\n        govFeesToken = 0;\n        devFeesWETH = 0;\n        govFeesWETH = 0;\n    }\n\n    // Manage tokens\n    function handleTokens(\n        address _a,\n        uint _amount,\n        bool _mint\n    ) external onlyTrading {\n        if (_mint) {\n            token.mint(_a, _amount);\n            tokensMinted += _amount;\n        } else {\n            token.burn(_a, _amount);\n            tokensBurned += _amount;\n        }\n    }\n\n    function transferWETH(\n        address _from,\n        address _to,\n        uint _amount\n    ) external onlyTrading {\n        if (_from == address(this)) {\n            WETH.transfer(_to, _amount);\n        } else {\n            WETH.transferFrom(_from, _to, _amount);\n        }\n    }\n\n    function transferLinkToAggregator(\n        address _from,\n        uint _pairIndex,\n        uint _leveragedPosWETH\n    ) external onlyTrading {\n        linkErc677.transferFrom(\n            _from,\n            address(priceAggregator),\n            priceAggregator.linkFee(_pairIndex, _leveragedPosWETH)\n        );\n    }\n\n    // View utils functions\n    function firstEmptyTradeIndex(\n        address trader,\n        uint pairIndex\n    ) public view returns (uint index) {\n        for (uint i = 0; i < maxTradesPerPair; i++) {\n            if (openTrades[trader][pairIndex][i].leverage == 0) {\n                index = i;\n                break;\n            }\n        }\n    }\n\n    function firstEmptyOpenLimitIndex(\n        address trader,\n        uint pairIndex\n    ) public view returns (uint index) {\n        for (uint i = 0; i < maxTradesPerPair; i++) {\n            if (!hasOpenLimitOrder(trader, pairIndex, i)) {\n                index = i;\n                break;\n            }\n        }\n    }\n\n    function hasOpenLimitOrder(\n        address trader,\n        uint pairIndex,\n        uint index\n    ) public view returns (bool) {\n        if (openLimitOrders.length == 0) {\n            return false;\n        }\n        OpenLimitOrder storage o = openLimitOrders[\n            openLimitOrderIds[trader][pairIndex][index]\n        ];\n        return\n            o.trader == trader && o.pairIndex == pairIndex && o.index == index;\n    }\n\n    // Additional getters\n    function getReferral(address _trader) external view returns (address) {\n        return traders[_trader].referral;\n    }\n\n    function getLeverageUnlocked(address _trader) external view returns (uint) {\n        return traders[_trader].leverageUnlocked;\n    }\n\n    function pairTradersArray(\n        uint _pairIndex\n    ) external view returns (address[] memory) {\n        return pairTraders[_pairIndex];\n    }\n\n    function getPendingOrderIds(\n        address _trader\n    ) external view returns (uint[] memory) {\n        return pendingOrderIds[_trader];\n    }\n\n    function pendingOrderIdsCount(\n        address _trader\n    ) external view returns (uint) {\n        return pendingOrderIds[_trader].length;\n    }\n\n    function getOpenLimitOrder(\n        address _trader,\n        uint _pairIndex,\n        uint _index\n    ) external view returns (OpenLimitOrder memory) {\n        require(hasOpenLimitOrder(_trader, _pairIndex, _index));\n        return openLimitOrders[openLimitOrderIds[_trader][_pairIndex][_index]];\n    }\n\n    function getOpenLimitOrders()\n        external\n        view\n        returns (OpenLimitOrder[] memory)\n    {\n        return openLimitOrders;\n    }\n\n    function getSupportedTokens() external view returns (address[] memory) {\n        return supportedTokens;\n    }\n\n    function getSpreadReductionsArray() external view returns (uint[5] memory) {\n        return spreadReductionsP;\n    }\n\n    function getGov() external view returns (address _gov) {\n        return gov;\n    }\n}\n"
    },
    "contracts/Trading.sol": {
      "content": "// SPDX-License-Identifier: MIT\nimport \"./interfaces/StorageInterface.sol\";\nimport \"./interfaces/PairInfosInterface.sol\";\nimport \"./interfaces/ReferralsInterface.sol\";\nimport \"./interfaces/BorrowingFeesInterface.sol\";\nimport \"./Delegatable.sol\";\nimport \"./libraries/ChainUtils.sol\";\nimport \"./libraries/TradeUtils.sol\";\nimport \"./libraries/PackingUtils.sol\";\nimport \"./interfaces/NFTRewardInterfaceV6_3.sol\";\n\npragma solidity 0.8.17;\n\ncontract Trading is Delegatable {\n    using TradeUtils for address;\n    using PackingUtils for uint256;\n\n    // Contracts (constant)\n    StorageInterface public immutable storageT;\n    NftRewardsInterfaceV6_3_1 public immutable nftRewards;\n    PairInfosInterface public immutable pairInfos;\n    ReferralsInterface public immutable referrals;\n    BorrowingFeesInterface public immutable borrowingFees;\n\n    // Params (constant)\n    uint constant PRECISION = 1e10;\n    uint constant MAX_SL_P = 75; // -75% PNL\n\n    // Params (adjustable)\n    uint public maxPosWETH; // 1e18 (eg. 75000 * 1e18)\n    uint public marketOrdersTimeout; // block (eg. 30)\n\n    // State\n    bool public isPaused; // Prevent opening new trades\n    bool public isDone; // Prevent any interaction with the contract\n\n    // Events\n    event Done(bool done);\n    event Paused(bool paused);\n\n    event NumberUpdated(string name, uint value);\n\n    event MarketOrderInitiated(\n        uint indexed orderId,\n        address indexed trader,\n        uint indexed pairIndex,\n        bool open\n    );\n\n    event OpenLimitPlaced(\n        address indexed trader,\n        uint indexed pairIndex,\n        uint index\n    );\n    event OpenLimitUpdated(\n        address indexed trader,\n        uint indexed pairIndex,\n        uint index,\n        uint newPrice,\n        uint newTp,\n        uint newSl,\n        uint maxSlippageP\n    );\n    event OpenLimitCanceled(\n        address indexed trader,\n        uint indexed pairIndex,\n        uint index\n    );\n\n    event TpUpdated(\n        address indexed trader,\n        uint indexed pairIndex,\n        uint index,\n        uint newTp\n    );\n    event SlUpdated(\n        address indexed trader,\n        uint indexed pairIndex,\n        uint index,\n        uint newSl\n    );\n\n    event NftOrderInitiated(\n        uint orderId,\n        address indexed nftHolder,\n        address indexed trader,\n        uint indexed pairIndex\n    );\n    event NftOrderSameBlock(\n        address indexed nftHolder,\n        address indexed trader,\n        uint indexed pairIndex\n    );\n\n    event ChainlinkCallbackTimeout(\n        uint indexed orderId,\n        StorageInterface.PendingMarketOrder order\n    );\n    event CouldNotCloseTrade(\n        address indexed trader,\n        uint indexed pairIndex,\n        uint index\n    );\n\n    constructor(\n        StorageInterface _storageT,\n        NftRewardsInterfaceV6_3_1 _nftRewards,\n        PairInfosInterface _pairInfos,\n        ReferralsInterface _referrals,\n        BorrowingFeesInterface _borrowingFees,\n        uint _maxPosWETH,\n        uint _marketOrdersTimeout\n    ) {\n        require(\n            address(_storageT) != address(0) &&\n                address(_nftRewards) != address(0) &&\n                address(_pairInfos) != address(0) &&\n                address(_referrals) != address(0) &&\n                address(_borrowingFees) != address(0) &&\n                _maxPosWETH > 0 &&\n                _marketOrdersTimeout > 0,\n            \"WRONG_PARAMS\"\n        );\n\n        storageT = _storageT;\n        nftRewards = _nftRewards;\n        pairInfos = _pairInfos;\n        referrals = _referrals;\n        borrowingFees = _borrowingFees;\n\n        maxPosWETH = _maxPosWETH;\n        marketOrdersTimeout = _marketOrdersTimeout;\n    }\n\n    // Modifiers\n    modifier onlyGov() {\n        isGov();\n        _;\n    }\n    modifier notContract() {\n        isNotContract();\n        _;\n    }\n    modifier notDone() {\n        isNotDone();\n        _;\n    }\n\n    // Saving code size by calling these functions inside modifiers\n    function isGov() private view {\n        require(msg.sender == storageT.gov(), \"GOV_ONLY\");\n    }\n\n    function isNotContract() private view {\n        require(tx.origin == msg.sender);\n    }\n\n    function isNotDone() private view {\n        require(!isDone, \"DONE\");\n    }\n\n    // Manage params\n    function setMaxPosWETH(uint value) external onlyGov {\n        require(value > 0, \"VALUE_0\");\n        maxPosWETH = value;\n        emit NumberUpdated(\"maxPosWETH\", value);\n    }\n\n    function setMarketOrdersTimeout(uint value) external onlyGov {\n        require(value > 0, \"VALUE_0\");\n        marketOrdersTimeout = value;\n        emit NumberUpdated(\"marketOrdersTimeout\", value);\n    }\n\n    // Manage state\n    function pause() external onlyGov {\n        isPaused = !isPaused;\n        emit Paused(isPaused);\n    }\n\n    function done() external onlyGov {\n        isDone = !isDone;\n        emit Done(isDone);\n    }\n\n    // Open new trade (MARKET/LIMIT)\n    function openTrade(\n        StorageInterface.Trade memory t,\n        NftRewardsInterfaceV6_3_1.OpenLimitOrderType orderType, // LEGACY => market\n        uint spreadReductionId,\n        uint slippageP // 1e10 (%)\n    )\n        external\n        // address referrer\n        notContract\n        notDone\n    {\n        require(!isPaused, \"PAUSED\");\n        require(t.openPrice * slippageP < type(uint256).max, \"OVERFLOW\");\n        require(t.openPrice > 0, \"PRICE_ZERO\");\n\n        AggregatorInterfaceV1_4 aggregator = storageT.priceAggregator();\n        PairsStorageInterfaceV6 pairsStored = aggregator.pairsStorage();\n\n        address sender = _msgSender();\n\n        require(\n            storageT.openTradesCount(sender, t.pairIndex) +\n                storageT.pendingMarketOpenCount(sender, t.pairIndex) +\n                storageT.openLimitOrdersCount(sender, t.pairIndex) <\n                storageT.maxTradesPerPair(),\n            \"MAX_TRADES_PER_PAIR\"\n        );\n\n        require(\n            storageT.pendingOrderIdsCount(sender) <\n                storageT.maxPendingMarketOrders(),\n            \"MAX_PENDING_ORDERS\"\n        );\n        require(t.positionSizeWETH <= maxPosWETH, \"ABOVE_MAX_POS\");\n        require(\n            t.positionSizeWETH * t.leverage >=\n                pairsStored.pairMinLevPosWETH(t.pairIndex),\n            \"BELOW_MIN_POS\"\n        );\n\n        require(\n            t.leverage > 0 &&\n                t.leverage >= pairsStored.pairMinLeverage(t.pairIndex) &&\n                t.leverage <= pairMaxLeverage(pairsStored, t.pairIndex),\n            \"LEVERAGE_INCORRECT\"\n        );\n\n        // require(\n        //     spreadReductionId == 0 ||\n        //         storageT.nfts(spreadReductionId - 1).balanceOf(sender) > 0,\n        //     \"NO_CORRESPONDING_NFT_SPREAD_REDUCTION\"\n        // );\n\n        require(\n            t.tp == 0 || (t.buy ? t.tp > t.openPrice : t.tp < t.openPrice),\n            \"WRONG_TP\"\n        );\n        require(\n            t.sl == 0 || (t.buy ? t.sl < t.openPrice : t.sl > t.openPrice),\n            \"WRONG_SL\"\n        );\n\n        (uint priceImpactP, ) = pairInfos.getTradePriceImpact(\n            0,\n            t.pairIndex,\n            t.buy,\n            t.positionSizeWETH * t.leverage\n        );\n        require(\n            priceImpactP * t.leverage <= pairInfos.maxNegativePnlOnOpenP(),\n            \"PRICE_IMPACT_TOO_HIGH\"\n        );\n\n        storageT.transferWETH(sender, address(storageT), t.positionSizeWETH);\n\n        if (orderType != NftRewardsInterfaceV6_3_1.OpenLimitOrderType.LEGACY) {\n            // uint index = storageT.firstEmptyOpenLimitIndex(sender, t.pairIndex);\n            // storageT.storeOpenLimitOrder(\n            //     StorageInterface.OpenLimitOrder(\n            //         sender,\n            //         t.pairIndex,\n            //         index,\n            //         t.positionSizeWETH,\n            //         spreadReductionId > 0\n            //             ? storageT.spreadReductionsP(spreadReductionId - 1)\n            //             : 0,\n            //         t.buy,\n            //         t.leverage,\n            //         t.tp,\n            //         t.sl,\n            //         t.openPrice,\n            //         t.openPrice,\n            //         block.number,\n            //         0\n            //     )\n            // );\n            // nftRewards.setOpenLimitOrderType(\n            //     sender,\n            //     t.pairIndex,\n            //     index,\n            //     orderType\n            // );\n            // address c = storageT.callbacks();\n            // c.setTradeLastUpdated(\n            //     sender,\n            //     t.pairIndex,\n            //     index,\n            //     TradingCallbacksInterface.TradeType.LIMIT,\n            //     ChainUtils.getBlockNumber()\n            // );\n            // c.setTradeData(\n            //     sender,\n            //     t.pairIndex,\n            //     index,\n            //     TradingCallbacksInterface.TradeType.LIMIT,\n            //     slippageP\n            // );\n            // emit OpenLimitPlaced(sender, t.pairIndex, index);\n        } else {\n            uint orderId = aggregator.getPrice(\n                t.pairIndex,\n                AggregatorInterfaceV1_4.OrderType.MARKET_OPEN,\n                t.positionSizeWETH * t.leverage,\n                ChainUtils.getBlockNumber()\n            );\n\n            storageT.storePendingMarketOrder(\n                StorageInterface.PendingMarketOrder(\n                    StorageInterface.Trade(\n                        sender,\n                        t.pairIndex,\n                        0,\n                        0,\n                        t.positionSizeWETH,\n                        0,\n                        t.buy,\n                        t.leverage,\n                        t.tp,\n                        t.sl\n                    ),\n                    0,\n                    t.openPrice,\n                    slippageP,\n                    0,\n                    0\n                ),\n                orderId,\n                true\n            );\n\n            emit MarketOrderInitiated(orderId, sender, t.pairIndex, true);\n        }\n\n        // referrals.registerPotentialReferrer(sender, referrer);\n    }\n\n    // Close trade (MARKET)\n    function closeTradeMarket(\n        uint pairIndex,\n        uint index\n    ) external notContract notDone {\n        address sender = _msgSender();\n\n        StorageInterface.Trade memory t = storageT.openTrades(\n            sender,\n            pairIndex,\n            index\n        );\n        StorageInterface.TradeInfo memory i = storageT.openTradesInfo(\n            sender,\n            pairIndex,\n            index\n        );\n\n        require(\n            storageT.pendingOrderIdsCount(sender) <\n                storageT.maxPendingMarketOrders(),\n            \"MAX_PENDING_ORDERS\"\n        );\n        require(!i.beingMarketClosed, \"ALREADY_BEING_CLOSED\");\n        require(t.leverage > 0, \"NO_TRADE\");\n\n        uint orderId = storageT.priceAggregator().getPrice(\n            pairIndex,\n            AggregatorInterfaceV1_4.OrderType.MARKET_CLOSE,\n            (t.initialPosToken * i.tokenPriceWETH * t.leverage) / PRECISION,\n            ChainUtils.getBlockNumber()\n        );\n\n        storageT.storePendingMarketOrder(\n            StorageInterface.PendingMarketOrder(\n                StorageInterface.Trade(\n                    sender,\n                    pairIndex,\n                    index,\n                    0,\n                    0,\n                    0,\n                    false,\n                    0,\n                    0,\n                    0\n                ),\n                0,\n                0,\n                0,\n                0,\n                0\n            ),\n            orderId,\n            false\n        );\n\n        emit MarketOrderInitiated(orderId, sender, pairIndex, false);\n    }\n\n    // Manage limit order (OPEN)\n    // function updateOpenLimitOrder(\n    //     uint pairIndex,\n    //     uint index,\n    //     uint price, // PRECISION\n    //     uint tp,\n    //     uint sl,\n    //     uint maxSlippageP\n    // ) external notContract notDone {\n    //     require(price > 0, \"PRICE_ZERO\");\n\n    //     address sender = _msgSender();\n    //     require(\n    //         storageT.hasOpenLimitOrder(sender, pairIndex, index),\n    //         \"NO_LIMIT\"\n    //     );\n\n    //     StorageInterface.OpenLimitOrder memory o = storageT.getOpenLimitOrder(\n    //         sender,\n    //         pairIndex,\n    //         index\n    //     );\n\n    //     require(tp == 0 || (o.buy ? tp > price : tp < price), \"WRONG_TP\");\n    //     require(sl == 0 || (o.buy ? sl < price : sl > price), \"WRONG_SL\");\n\n    //     require(price * maxSlippageP < type(uint256).max, \"OVERFLOW\");\n\n    //     checkNoPendingTrigger(\n    //         sender,\n    //         pairIndex,\n    //         index,\n    //         StorageInterface.LimitOrder.OPEN\n    //     );\n\n    //     o.minPrice = price;\n    //     o.maxPrice = price;\n    //     o.tp = tp;\n    //     o.sl = sl;\n\n    //     storageT.updateOpenLimitOrder(o);\n\n    //     address c = storageT.callbacks();\n    //     c.setTradeLastUpdated(\n    //         sender,\n    //         pairIndex,\n    //         index,\n    //         TradingCallbacksInterface.TradeType.LIMIT,\n    //         ChainUtils.getBlockNumber()\n    //     );\n    //     c.setTradeData(\n    //         sender,\n    //         pairIndex,\n    //         index,\n    //         TradingCallbacksInterface.TradeType.LIMIT,\n    //         maxSlippageP\n    //     );\n\n    //     emit OpenLimitUpdated(\n    //         sender,\n    //         pairIndex,\n    //         index,\n    //         price,\n    //         tp,\n    //         sl,\n    //         maxSlippageP\n    //     );\n    // }\n\n    // function cancelOpenLimitOrder(\n    //     uint pairIndex,\n    //     uint index\n    // ) external notContract notDone {\n    //     address sender = _msgSender();\n    //     require(\n    //         storageT.hasOpenLimitOrder(sender, pairIndex, index),\n    //         \"NO_LIMIT\"\n    //     );\n\n    //     StorageInterface.OpenLimitOrder memory o = storageT.getOpenLimitOrder(\n    //         sender,\n    //         pairIndex,\n    //         index\n    //     );\n\n    //     checkNoPendingTrigger(\n    //         sender,\n    //         pairIndex,\n    //         index,\n    //         StorageInterface.LimitOrder.OPEN\n    //     );\n\n    //     storageT.unregisterOpenLimitOrder(sender, pairIndex, index);\n    //     storageT.transferWETH(address(storageT), sender, o.positionSize);\n\n    //     emit OpenLimitCanceled(sender, pairIndex, index);\n    // }\n\n    // Manage limit order (TP/SL)\n    function updateTp(\n        uint pairIndex,\n        uint index,\n        uint newTp\n    ) external notContract notDone {\n        address sender = _msgSender();\n\n        // checkNoPendingTrigger(\n        //     sender,\n        //     pairIndex,\n        //     index,\n        //     StorageInterface.LimitOrder.TP\n        // );\n\n        StorageInterface.Trade memory t = storageT.openTrades(\n            sender,\n            pairIndex,\n            index\n        );\n        require(t.leverage > 0, \"NO_TRADE\");\n\n        storageT.updateTp(sender, pairIndex, index, newTp);\n        storageT.callbacks().setTpLastUpdated(\n            sender,\n            pairIndex,\n            index,\n            TradingCallbacksInterface.TradeType.MARKET,\n            ChainUtils.getBlockNumber()\n        );\n\n        emit TpUpdated(sender, pairIndex, index, newTp);\n    }\n\n    function updateSl(\n        uint pairIndex,\n        uint index,\n        uint newSl\n    ) external notContract notDone {\n        address sender = _msgSender();\n\n        // checkNoPendingTrigger(\n        //     sender,\n        //     pairIndex,\n        //     index,\n        //     StorageInterface.LimitOrder.SL\n        // );\n\n        StorageInterface.Trade memory t = storageT.openTrades(\n            sender,\n            pairIndex,\n            index\n        );\n        require(t.leverage > 0, \"NO_TRADE\");\n\n        uint maxSlDist = (t.openPrice * MAX_SL_P) / 100 / t.leverage;\n\n        require(\n            newSl == 0 ||\n                (\n                    t.buy\n                        ? newSl >= t.openPrice - maxSlDist\n                        : newSl <= t.openPrice + maxSlDist\n                ),\n            \"SL_TOO_BIG\"\n        );\n\n        storageT.updateSl(sender, pairIndex, index, newSl);\n        storageT.callbacks().setSlLastUpdated(\n            sender,\n            pairIndex,\n            index,\n            TradingCallbacksInterface.TradeType.MARKET,\n            ChainUtils.getBlockNumber()\n        );\n\n        emit SlUpdated(sender, pairIndex, index, newSl);\n    }\n\n    // // Execute limit order\n    // function executeNftOrder(uint256 packed) external notContract notDone {\n    //     (\n    //         uint _orderType,\n    //         address trader,\n    //         uint pairIndex,\n    //         uint index,\n    //         uint nftId,\n    //         uint nftType\n    //     ) = packed.unpackExecuteNftOrder();\n    //     StorageInterface.LimitOrder orderType = StorageInterface.LimitOrder(\n    //         _orderType\n    //     );\n    //     address sender = _msgSender();\n\n    //     require(nftType >= 1 && nftType <= 5, \"WRONG_NFT_TYPE\");\n    //     require(storageT.nfts(nftType - 1).ownerOf(nftId) == sender, \"NO_NFT\");\n\n    //     require(\n    //         block.number >=\n    //             storageT.nftLastSuccess(nftId) + storageT.nftSuccessTimelock(),\n    //         \"SUCCESS_TIMELOCK\"\n    //     );\n\n    //     bool isOpenLimit = orderType == StorageInterface.LimitOrder.OPEN;\n    //     TradingCallbacksInterface.TradeType tradeType = isOpenLimit\n    //         ? TradingCallbacksInterface.TradeType.LIMIT\n    //         : TradingCallbacksInterface.TradeType.MARKET;\n\n    //     require(\n    //         canExecute(\n    //             orderType,\n    //             TradingCallbacksInterface.SimplifiedTradeId(\n    //                 trader,\n    //                 pairIndex,\n    //                 index,\n    //                 tradeType\n    //             )\n    //         ),\n    //         \"IN_TIMEOUT\"\n    //     );\n\n    //     handleBotInUse(sender, nftId, trader, pairIndex, index);\n\n    //     StorageInterface.Trade memory t;\n\n    //     if (isOpenLimit) {\n    //         require(\n    //             storageT.hasOpenLimitOrder(trader, pairIndex, index),\n    //             \"NO_LIMIT\"\n    //         );\n    //     } else {\n    //         t = storageT.openTrades(trader, pairIndex, index);\n\n    //         require(t.leverage > 0, \"NO_TRADE\");\n\n    //         if (orderType == StorageInterface.LimitOrder.LIQ) {\n    //             uint liqPrice = borrowingFees.getTradeLiquidationPrice(\n    //                 BorrowingFeesInterface.LiqPriceInput(\n    //                     t.trader,\n    //                     t.pairIndex,\n    //                     t.index,\n    //                     t.openPrice,\n    //                     t.buy,\n    //                     (t.initialPosToken *\n    //                         storageT\n    //                             .openTradesInfo(t.trader, t.pairIndex, t.index)\n    //                             .tokenPriceWETH) / PRECISION,\n    //                     t.leverage\n    //                 )\n    //             );\n\n    //             require(\n    //                 t.sl == 0 || (t.buy ? liqPrice > t.sl : liqPrice < t.sl),\n    //                 \"HAS_SL\"\n    //             );\n    //         } else {\n    //             require(\n    //                 orderType != StorageInterface.LimitOrder.SL || t.sl > 0,\n    //                 \"NO_SL\"\n    //             );\n    //             require(\n    //                 orderType != StorageInterface.LimitOrder.TP || t.tp > 0,\n    //                 \"NO_TP\"\n    //             );\n    //         }\n    //     }\n\n    //     NftRewardsInterfaceV6_3_1.TriggeredLimitId\n    //         memory triggeredLimitId = NftRewardsInterfaceV6_3_1\n    //             .TriggeredLimitId(trader, pairIndex, index, orderType);\n\n    //     if (\n    //         !nftRewards.triggered(triggeredLimitId) ||\n    //         nftRewards.timedOut(triggeredLimitId)\n    //     ) {\n    //         uint leveragedPosWETH;\n\n    //         if (isOpenLimit) {\n    //             StorageInterface.OpenLimitOrder memory l = storageT\n    //                 .getOpenLimitOrder(trader, pairIndex, index);\n\n    //             leveragedPosWETH = l.positionSize * l.leverage;\n    //             (uint priceImpactP, ) = pairInfos.getTradePriceImpact(\n    //                 0,\n    //                 l.pairIndex,\n    //                 l.buy,\n    //                 leveragedPosWETH\n    //             );\n\n    //             require(\n    //                 priceImpactP * l.leverage <=\n    //                     pairInfos.maxNegativePnlOnOpenP(),\n    //                 \"PRICE_IMPACT_TOO_HIGH\"\n    //             );\n    //         } else {\n    //             leveragedPosWETH =\n    //                 (t.initialPosToken *\n    //                     storageT\n    //                         .openTradesInfo(trader, pairIndex, index)\n    //                         .tokenPriceWETH *\n    //                     t.leverage) /\n    //                 PRECISION;\n    //         }\n\n    //         storageT.transferLinkToAggregator(\n    //             sender,\n    //             pairIndex,\n    //             leveragedPosWETH\n    //         );\n\n    //         (uint orderId, uint linkFee) = getPriceNftOrder(\n    //             isOpenLimit,\n    //             trader,\n    //             pairIndex,\n    //             index,\n    //             tradeType,\n    //             orderType,\n    //             leveragedPosWETH\n    //         );\n\n    //         StorageInterface.PendingNftOrder memory pendingNftOrder;\n    //         pendingNftOrder.nftHolder = sender;\n    //         pendingNftOrder.nftId = nftId;\n    //         pendingNftOrder.trader = trader;\n    //         pendingNftOrder.pairIndex = pairIndex;\n    //         pendingNftOrder.index = index;\n    //         pendingNftOrder.orderType = orderType;\n\n    //         storageT.storePendingNftOrder(pendingNftOrder, orderId);\n    //         nftRewards.storeFirstToTrigger(triggeredLimitId, sender, linkFee);\n\n    //         emit NftOrderInitiated(orderId, sender, trader, pairIndex);\n    //     } else {\n    //         nftRewards.storeTriggerSameBlock(triggeredLimitId, sender);\n\n    //         emit NftOrderSameBlock(sender, trader, pairIndex);\n    //     }\n    // }\n\n    // Market timeout\n    function openTradeMarketTimeout(uint _order) external notContract notDone {\n        address sender = _msgSender();\n\n        StorageInterface.PendingMarketOrder memory o = storageT\n            .reqID_pendingMarketOrder(_order);\n        StorageInterface.Trade memory t = o.trade;\n\n        require(\n            o.block > 0 && block.number >= o.block + marketOrdersTimeout,\n            \"WAIT_TIMEOUT\"\n        );\n        require(t.trader == sender, \"NOT_YOUR_ORDER\");\n        require(t.leverage > 0, \"WRONG_MARKET_ORDER_TYPE\");\n\n        storageT.unregisterPendingMarketOrder(_order, true);\n        storageT.transferWETH(address(storageT), sender, t.positionSizeWETH);\n\n        emit ChainlinkCallbackTimeout(_order, o);\n    }\n\n    function closeTradeMarketTimeout(uint _order) external notContract notDone {\n        address sender = _msgSender();\n\n        StorageInterface.PendingMarketOrder memory o = storageT\n            .reqID_pendingMarketOrder(_order);\n        StorageInterface.Trade memory t = o.trade;\n\n        require(\n            o.block > 0 && block.number >= o.block + marketOrdersTimeout,\n            \"WAIT_TIMEOUT\"\n        );\n        require(t.trader == sender, \"NOT_YOUR_ORDER\");\n        require(t.leverage == 0, \"WRONG_MARKET_ORDER_TYPE\");\n\n        storageT.unregisterPendingMarketOrder(_order, false);\n\n        (bool success, ) = address(this).delegatecall(\n            abi.encodeWithSignature(\n                \"closeTradeMarket(uint256,uint256)\",\n                t.pairIndex,\n                t.index\n            )\n        );\n\n        if (!success) {\n            emit CouldNotCloseTrade(sender, t.pairIndex, t.index);\n        }\n\n        emit ChainlinkCallbackTimeout(_order, o);\n    }\n\n    // Helpers\n    // function checkNoPendingTrigger(\n    //     address trader,\n    //     uint pairIndex,\n    //     uint index,\n    //     StorageInterface.LimitOrder orderType\n    // ) private view {\n    //     NftRewardsInterfaceV6_3_1.TriggeredLimitId\n    //         memory triggeredLimitId = NftRewardsInterfaceV6_3_1\n    //             .TriggeredLimitId(trader, pairIndex, index, orderType);\n    //     require(\n    //         !nftRewards.triggered(triggeredLimitId) ||\n    //             nftRewards.timedOut(triggeredLimitId),\n    //         \"PENDING_TRIGGER\"\n    //     );\n    // }\n\n    // function canExecute(\n    //     StorageInterface.LimitOrder orderType,\n    //     TradingCallbacksInterface.SimplifiedTradeId memory id\n    // ) private view returns (bool) {\n    //     if (orderType == StorageInterface.LimitOrder.LIQ) return true;\n\n    //     uint b = ChainUtils.getBlockNumber();\n    //     address cb = storageT.callbacks();\n\n    //     if (orderType == StorageInterface.LimitOrder.TP)\n    //         return !cb.isTpInTimeout(id, b);\n    //     if (orderType == StorageInterface.LimitOrder.SL)\n    //         return !cb.isSlInTimeout(id, b);\n\n    //     return !cb.isLimitInTimeout(id, b);\n    // }\n\n    function pairMaxLeverage(\n        PairsStorageInterfaceV6 pairsStored,\n        uint pairIndex\n    ) private view returns (uint) {\n        uint max = TradingCallbacksInterface(storageT.callbacks())\n            .pairMaxLeverage(pairIndex);\n        return max > 0 ? max : pairsStored.pairMaxLeverage(pairIndex);\n    }\n\n    // function handleBotInUse(\n    //     address sender,\n    //     uint nftId,\n    //     address trader,\n    //     uint pairIndex,\n    //     uint index\n    // ) private {\n    //     (bytes32 nftHash, bytes32 botHash) = nftRewards.getNftBotHashes(\n    //         block.number,\n    //         sender,\n    //         nftId,\n    //         trader,\n    //         pairIndex,\n    //         index\n    //     );\n    //     require(!nftRewards.nftBotInUse(nftHash, botHash), \"BOT_IN_USE\");\n\n    //     nftRewards.setNftBotInUse(nftHash, botHash);\n    // }\n\n    // function getPriceNftOrder(\n    //     bool isOpenLimit,\n    //     address trader,\n    //     uint pairIndex,\n    //     uint index,\n    //     TradingCallbacksInterface.TradeType tradeType,\n    //     StorageInterface.LimitOrder orderType,\n    //     uint leveragedPosWETH\n    // ) private returns (uint orderId, uint linkFee) {\n    //     TradingCallbacksInterface.LastUpdated\n    //         memory lastUpdated = TradingCallbacksInterface(storageT.callbacks())\n    //             .tradeLastUpdated(trader, pairIndex, index, tradeType);\n\n    //     AggregatorInterfaceV1_4 aggregator = storageT.priceAggregator();\n\n    //     orderId = aggregator.getPrice(\n    //         pairIndex,\n    //         isOpenLimit\n    //             ? AggregatorInterfaceV1_4.OrderType.LIMIT_OPEN\n    //             : AggregatorInterfaceV1_4.OrderType.LIMIT_CLOSE,\n    //         leveragedPosWETH,\n    //         isOpenLimit\n    //             ? lastUpdated.limit\n    //             : orderType == StorageInterface.LimitOrder.SL\n    //             ? lastUpdated.sl\n    //             : orderType == StorageInterface.LimitOrder.TP\n    //             ? lastUpdated.tp\n    //             : lastUpdated.created\n    //     );\n\n    //     linkFee = aggregator.linkFee(pairIndex, leveragedPosWETH);\n    // }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 125
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}