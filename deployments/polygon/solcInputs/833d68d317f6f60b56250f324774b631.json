{
  "language": "Solidity",
  "sources": {
    "contracts/contracts6_1/GNSPairInfosV6_1.sol": {
      "content": "/**\n *Submitted for verification at PolygonScan.com on 2022-06-29\n*/\n\n// File: contracts\\interfaces\\UniswapRouterInterfaceV5.sol\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.14;\n\ninterface UniswapRouterInterfaceV5{\n\tfunction swapExactTokensForTokens(\n\t\tuint amountIn,\n\t\tuint amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external returns (uint[] memory amounts);\n\n\tfunction swapTokensForExactTokens(\n\t\tuint amountOut,\n\t\tuint amountInMax,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external returns (uint[] memory amounts);\n}\n\n// File: contracts\\interfaces\\TokenInterfaceV5.sol\n\npragma solidity 0.8.14;\n\ninterface TokenInterfaceV5{\n    function burn(address, uint256) external;\n    function mint(address, uint256) external;\n    function transfer(address, uint256) external returns (bool);\n    function transferFrom(address, address, uint256) external returns(bool);\n    function balanceOf(address) external view returns(uint256);\n    function hasRole(bytes32, address) external view returns (bool);\n    function approve(address, uint256) external returns (bool);\n    function allowance(address, address) external view returns (uint256);\n}\n\n// File: contracts\\interfaces\\NftInterfaceV5.sol\n\npragma solidity 0.8.14;\n\ninterface NftInterfaceV5{\n    function balanceOf(address) external view returns (uint);\n    function ownerOf(uint) external view returns (address);\n    function transferFrom(address, address, uint) external;\n    function tokenOfOwnerByIndex(address, uint) external view returns(uint);\n}\n\n// File: contracts\\interfaces\\VaultInterfaceV5.sol\n\npragma solidity 0.8.14;\n\ninterface VaultInterfaceV5{\n\tfunction sendWETHToTrader(address, uint) external;\n\tfunction receiveWETHFromTrader(address, uint, uint) external;\n\tfunction currentBalanceWETH() external view returns(uint);\n\tfunction distributeRewardWETH(uint) external;\n}\n\n// File: contracts\\interfaces\\PairsStorageInterfaceV6.sol\n\npragma solidity 0.8.14;\n\ninterface PairsStorageInterfaceV6{\n    enum FeedCalculation { DEFAULT, INVERT, COMBINE }    // FEED 1, 1 / (FEED 1), (FEED 1)/(FEED 2)\n    struct Feed{ address feed1; address feed2; FeedCalculation feedCalculation; uint maxDeviationP; } // PRECISION (%)\n    function incrementCurrentOrderId() external returns(uint);\n    function updateGroupCollateral(uint, uint, bool, bool) external;\n    function pairJob(uint) external returns(string memory, string memory, bytes32, uint);\n    function pairFeed(uint) external view returns(Feed memory);\n    function pairSpreadP(uint) external view returns(uint);\n    function pairMinLeverage(uint) external view returns(uint);\n    function pairMaxLeverage(uint) external view returns(uint);\n    function groupMaxCollateral(uint) external view returns(uint);\n    function groupCollateral(uint, bool) external view returns(uint);\n    function guaranteedSlEnabled(uint) external view returns(bool);\n    function pairOpenFeeP(uint) external view returns(uint);\n    function pairCloseFeeP(uint) external view returns(uint);\n    function pairOracleFeeP(uint) external view returns(uint);\n    function pairNftLimitOrderFeeP(uint) external view returns(uint);\n    function pairReferralFeeP(uint) external view returns(uint);\n    function pairMinLevPosWETH(uint) external view returns(uint);\n}\n\n// File: contracts\\interfaces\\StorageInterfaceV5.sol\n\npragma solidity 0.8.14;\n\ninterface StorageInterfaceV5{\n    enum LimitOrder { TP, SL, LIQ, OPEN }\n    struct Trader{\n        uint leverageUnlocked;\n        address referral;\n        uint referralRewardsTotal;  // 1e18\n    }\n    struct Trade{\n        address trader;\n        uint pairIndex;\n        uint index;\n        uint initialPosToken;       // 1e18\n        uint positionSizeWETH;       // 1e18\n        uint openPrice;             // PRECISION\n        bool buy;\n        uint leverage;\n        uint tp;                    // PRECISION\n        uint sl;                    // PRECISION\n    }\n    struct TradeInfo{\n        uint tokenId;\n        uint tokenPriceWETH;         // PRECISION\n        uint openInterestWETH;       // 1e18\n        uint tpLastUpdated;\n        uint slLastUpdated;\n        bool beingMarketClosed;\n    }\n    struct OpenLimitOrder{\n        address trader;\n        uint pairIndex;\n        uint index;\n        uint positionSize;          // 1e18 (WETH or GFARM2)\n        uint spreadReductionP;\n        bool buy;\n        uint leverage;\n        uint tp;                    // PRECISION (%)\n        uint sl;                    // PRECISION (%)\n        uint minPrice;              // PRECISION\n        uint maxPrice;              // PRECISION\n        uint block;\n        uint tokenId;               // index in supportedTokens\n    }\n    struct PendingMarketOrder{\n        Trade trade;\n        uint block;\n        uint wantedPrice;           // PRECISION\n        uint slippageP;             // PRECISION (%)\n        uint spreadReductionP;\n        uint tokenId;               // index in supportedTokens\n    }\n    struct PendingNftOrder{\n        address nftHolder;\n        uint nftId;\n        address trader;\n        uint pairIndex;\n        uint index;\n        LimitOrder orderType;\n    }\n    function PRECISION() external pure returns(uint);\n    function gov() external view returns(address);\n    function dev() external view returns(address);\n    function WETH() external view returns(TokenInterfaceV5);\n    function token() external view returns(TokenInterfaceV5);\n    function linkErc677() external view returns(TokenInterfaceV5);\n    function tokenWETHRouter() external view returns(UniswapRouterInterfaceV5);\n    function priceAggregator() external view returns(AggregatorInterfaceV6);\n    function vault() external view returns(VaultInterfaceV5);\n    function trading() external view returns(address);\n    function callbacks() external view returns(address);\n    function handleTokens(address,uint,bool) external;\n    function transferWETH(address, address, uint) external;\n    function transferLinkToAggregator(address, uint, uint) external;\n    function unregisterTrade(address, uint, uint) external;\n    function unregisterPendingMarketOrder(uint, bool) external;\n    function unregisterOpenLimitOrder(address, uint, uint) external;\n    function hasOpenLimitOrder(address, uint, uint) external view returns(bool);\n    function storePendingMarketOrder(PendingMarketOrder memory, uint, bool) external;\n    function storeReferral(address, address) external;\n    function openTrades(address, uint, uint) external view returns(Trade memory);\n    function openTradesInfo(address, uint, uint) external view returns(TradeInfo memory);\n    function updateSl(address, uint, uint, uint) external;\n    function updateTp(address, uint, uint, uint) external;\n    function getOpenLimitOrder(address, uint, uint) external view returns(OpenLimitOrder memory);\n    function spreadReductionsP(uint) external view returns(uint);\n    function positionSizeTokenDynamic(uint,uint) external view returns(uint);\n    function maxSlP() external view returns(uint);\n    function storeOpenLimitOrder(OpenLimitOrder memory) external;\n    function reqID_pendingMarketOrder(uint) external view returns(PendingMarketOrder memory);\n    function storePendingNftOrder(PendingNftOrder memory, uint) external;\n    function updateOpenLimitOrder(OpenLimitOrder calldata) external;\n    function firstEmptyTradeIndex(address, uint) external view returns(uint);\n    function firstEmptyOpenLimitIndex(address, uint) external view returns(uint);\n    function increaseNftRewards(uint, uint) external;\n    function nftSuccessTimelock() external view returns(uint);\n    function currentPercentProfit(uint,uint,bool,uint) external view returns(int);\n    function reqID_pendingNftOrder(uint) external view returns(PendingNftOrder memory);\n    function setNftLastSuccess(uint) external;\n    function updateTrade(Trade memory) external;\n    function nftLastSuccess(uint) external view returns(uint);\n    function unregisterPendingNftOrder(uint) external;\n    function handleDevGovFees(uint, uint, bool, bool) external returns(uint);\n    function distributeLpRewards(uint) external;\n    function getReferral(address) external view returns(address);\n    function increaseReferralRewards(address, uint) external;\n    function storeTrade(Trade memory, TradeInfo memory) external;\n    function setLeverageUnlocked(address, uint) external;\n    function getLeverageUnlocked(address) external view returns(uint);\n    function openLimitOrdersCount(address, uint) external view returns(uint);\n    function maxOpenLimitOrdersPerPair() external view returns(uint);\n    function openTradesCount(address, uint) external view returns(uint);\n    function pendingMarketOpenCount(address, uint) external view returns(uint);\n    function pendingMarketCloseCount(address, uint) external view returns(uint);\n    function maxTradesPerPair() external view returns(uint);\n    function maxTradesPerBlock() external view returns(uint);\n    function tradesPerBlock(uint) external view returns(uint);\n    function pendingOrderIdsCount(address) external view returns(uint);\n    function maxPendingMarketOrders() external view returns(uint);\n    function maxGainP() external view returns(uint);\n    function defaultLeverageUnlocked() external view returns(uint);\n    function openInterestWETH(uint, uint) external view returns(uint);\n    function getPendingOrderIds(address) external view returns(uint[] memory);\n    function traders(address) external view returns(Trader memory);\n    function nfts(uint) external view returns(NftInterfaceV5);\n}\n\ninterface AggregatorInterfaceV6{\n    enum OrderType { MARKET_OPEN, MARKET_CLOSE, LIMIT_OPEN, LIMIT_CLOSE, UPDATE_SL }\n    function pairsStorage() external view returns(PairsStorageInterfaceV6);\n    function nftRewards() external view returns(NftRewardsInterfaceV6);\n    function getPrice(uint,OrderType,uint) external returns(uint);\n    function tokenPriceWETH() external view returns(uint);\n    function linkFee(uint,uint) external view returns(uint);\n    function tokenWETHReservesLp() external view returns(uint, uint);\n    function pendingSlOrders(uint) external view returns(PendingSl memory);\n    function storePendingSlOrder(uint orderId, PendingSl calldata p) external;\n    function unregisterPendingSlOrder(uint orderId) external;\n    struct PendingSl{address trader; uint pairIndex; uint index; uint openPrice; bool buy; uint newSl; }\n}\n\ninterface NftRewardsInterfaceV6{\n    struct TriggeredLimitId{ address trader; uint pairIndex; uint index; StorageInterfaceV5.LimitOrder order; }\n    enum OpenLimitOrderType{ LEGACY, REVERSAL, MOMENTUM }\n    function storeFirstToTrigger(TriggeredLimitId calldata, address) external;\n    function storeTriggerSameBlock(TriggeredLimitId calldata, address) external;\n    function unregisterTrigger(TriggeredLimitId calldata) external;\n    function distributeNftReward(TriggeredLimitId calldata, uint) external;\n    function openLimitOrderTypes(address, uint, uint) external view returns(OpenLimitOrderType);\n    function setOpenLimitOrderType(address, uint, uint, OpenLimitOrderType) external;\n    function triggered(TriggeredLimitId calldata) external view returns(bool);\n    function timedOut(TriggeredLimitId calldata) external view returns(bool);\n}\n\n// File: contracts\\GNSPairInfosV6_1.sol\n\npragma solidity 0.8.14;\n\ncontract GNSPairInfosV6_1 {\n\n    // Addresses\n    StorageInterfaceV5 immutable storageT;\n    address public manager;\n\n    // Constant parameters\n    uint constant PRECISION = 1e10;     // 10 decimals\n    uint constant LIQ_THRESHOLD_P = 90; // -90% (of collateral)\n\n    // Adjustable parameters\n    uint public maxNegativePnlOnOpenP = 40 * PRECISION; // PRECISION (%)\n\n    // Pair parameters\n    struct PairParams{\n        uint onePercentDepthAbove; // WETH\n        uint onePercentDepthBelow; // WETH\n        uint rolloverFeePerBlockP; // PRECISION (%)\n        uint fundingFeePerBlockP;  // PRECISION (%)\n    }\n\n    mapping(uint => PairParams) public pairParams;\n\n    // Pair acc funding fees\n    struct PairFundingFees{\n        int accPerOiLong;  // 1e18 (WETH)\n        int accPerOiShort; // 1e18 (WETH)\n        uint lastUpdateBlock;\n    }\n\n    mapping(uint => PairFundingFees) public pairFundingFees;\n\n    // Pair acc rollover fees\n    struct PairRolloverFees{\n        uint accPerCollateral; // 1e18 (WETH)\n        uint lastUpdateBlock;\n    }\n\n    mapping(uint => PairRolloverFees) public pairRolloverFees;\n\n    // Trade initial acc fees\n    struct TradeInitialAccFees{\n        uint rollover; // 1e18 (WETH)\n        int funding;   // 1e18 (WETH)\n        bool openedAfterUpdate;\n    }\n\n    mapping(\n        address => mapping(\n            uint => mapping(\n                uint => TradeInitialAccFees\n            )\n        )\n    ) public tradeInitialAccFees;\n\n    // Events\n    event ManagerUpdated(address value);\n    event MaxNegativePnlOnOpenPUpdated(uint value);\n    \n    event PairParamsUpdated(uint pairIndex, PairParams value);\n    event OnePercentDepthUpdated(uint pairIndex, uint valueAbove, uint valueBelow);\n    event RolloverFeePerBlockPUpdated(uint pairIndex, uint value);\n    event FundingFeePerBlockPUpdated(uint pairIndex, uint value);\n\n    event TradeInitialAccFeesStored(\n        address trader,\n        uint pairIndex,\n        uint index,\n        uint rollover,\n        int funding\n    );\n\n    event AccFundingFeesStored(uint pairIndex, int valueLong, int valueShort);\n    event AccRolloverFeesStored(uint pairIndex, uint value);\n\n    event FeesCharged(\n        uint pairIndex,\n        bool long,\n        uint collateral,   // 1e18 (WETH)\n        uint leverage,\n        int percentProfit, // PRECISION (%)\n        uint rolloverFees, // 1e18 (WETH)\n        int fundingFees    // 1e18 (WETH)\n    );\n\n    constructor(StorageInterfaceV5 _storageT){\n        storageT = _storageT;\n    }\n\n    // Modifiers\n    modifier onlyGov(){\n        require(msg.sender == storageT.gov(), \"GOV_ONLY\");\n        _;\n    }\n    modifier onlyManager(){\n        require(msg.sender == manager, \"MANAGER_ONLY\");\n        _;\n    }\n    modifier onlyCallbacks(){\n        require(msg.sender == storageT.callbacks(), \"CALLBACKS_ONLY\");\n        _;\n    }\n\n    // Set manager address\n    function setManager(address _manager) external onlyGov{\n        manager = _manager;\n\n        emit ManagerUpdated(_manager);\n    }\n\n    // Set max negative PnL % on trade opening\n    function setMaxNegativePnlOnOpenP(uint value) external onlyManager{\n        maxNegativePnlOnOpenP = value;\n\n        emit MaxNegativePnlOnOpenPUpdated(value);\n    }\n\n    // Set parameters for pair\n    function setPairParams(uint pairIndex, PairParams memory value) public onlyManager{\n        storeAccRolloverFees(pairIndex);\n        storeAccFundingFees(pairIndex);\n\n        pairParams[pairIndex] = value;\n\n        emit PairParamsUpdated(pairIndex, value);\n    }\n    function setPairParamsArray(\n        uint[] memory indices,\n        PairParams[] memory values\n    ) external onlyManager{\n        require(indices.length == values.length, \"WRONG_LENGTH\");\n\n        for(uint i = 0; i < indices.length; i++){\n            setPairParams(indices[i], values[i]);\n        }\n    }\n\n    // Set one percent depth for pair\n    function setOnePercentDepth(\n        uint pairIndex,\n        uint valueAbove,\n        uint valueBelow\n    ) public onlyManager{\n        PairParams storage p = pairParams[pairIndex];\n\n        p.onePercentDepthAbove = valueAbove;\n        p.onePercentDepthBelow = valueBelow;\n        \n        emit OnePercentDepthUpdated(pairIndex, valueAbove, valueBelow);\n    }\n    function setOnePercentDepthArray(\n        uint[] memory indices,\n        uint[] memory valuesAbove,\n        uint[] memory valuesBelow\n    ) external onlyManager{\n        require(indices.length == valuesAbove.length\n            && indices.length == valuesBelow.length, \"WRONG_LENGTH\");\n\n        for(uint i = 0; i < indices.length; i++){\n            setOnePercentDepth(indices[i], valuesAbove[i], valuesBelow[i]);\n        }\n    }\n\n    // Set rollover fee for pair\n    function setRolloverFeePerBlockP(uint pairIndex, uint value) public onlyManager{\n        require(value <= 25000000, \"TOO_HIGH\"); // ≈ 100% per day\n\n        storeAccRolloverFees(pairIndex);\n\n        pairParams[pairIndex].rolloverFeePerBlockP = value;\n        \n        emit RolloverFeePerBlockPUpdated(pairIndex, value);\n    }\n    function setRolloverFeePerBlockPArray(\n        uint[] memory indices,\n        uint[] memory values\n    ) external onlyManager{\n        require(indices.length == values.length, \"WRONG_LENGTH\");\n\n        for(uint i = 0; i < indices.length; i++){\n            setRolloverFeePerBlockP(indices[i], values[i]);\n        }\n    }\n\n    // Set funding fee for pair\n    function setFundingFeePerBlockP(uint pairIndex, uint value) public onlyManager{\n        require(value <= 10000000, \"TOO_HIGH\"); // ≈ 40% per day\n\n        storeAccFundingFees(pairIndex);\n\n        pairParams[pairIndex].fundingFeePerBlockP = value;\n        \n        emit FundingFeePerBlockPUpdated(pairIndex, value);\n    }\n    function setFundingFeePerBlockPArray(\n        uint[] memory indices,\n        uint[] memory values\n    ) external onlyManager{\n        require(indices.length == values.length, \"WRONG_LENGTH\");\n\n        for(uint i = 0; i < indices.length; i++){\n            setFundingFeePerBlockP(indices[i], values[i]);\n        }\n    }\n\n    // Store trade details when opened (acc fee values)\n    function storeTradeInitialAccFees(\n        address trader,\n        uint pairIndex,\n        uint index,\n        bool long\n    ) external onlyCallbacks{\n        storeAccFundingFees(pairIndex);\n\n        TradeInitialAccFees storage t = tradeInitialAccFees[trader][pairIndex][index];\n\n        t.rollover = getPendingAccRolloverFees(pairIndex);\n\n        t.funding = long ? \n            pairFundingFees[pairIndex].accPerOiLong :\n            pairFundingFees[pairIndex].accPerOiShort;\n\n        t.openedAfterUpdate = true;\n\n        emit TradeInitialAccFeesStored(trader, pairIndex, index, t.rollover, t.funding);\n    }\n\n    // Acc rollover fees (store right before fee % update)\n    function storeAccRolloverFees(uint pairIndex) private{\n        PairRolloverFees storage r = pairRolloverFees[pairIndex];\n\n        r.accPerCollateral = getPendingAccRolloverFees(pairIndex);\n        r.lastUpdateBlock = block.number;\n\n        emit AccRolloverFeesStored(pairIndex, r.accPerCollateral);\n    }\n    function getPendingAccRolloverFees(\n        uint pairIndex\n    ) public view returns(uint){ // 1e18 (WETH)\n        PairRolloverFees storage r = pairRolloverFees[pairIndex];\n        \n        return r.accPerCollateral +\n            (block.number - r.lastUpdateBlock)\n            * pairParams[pairIndex].rolloverFeePerBlockP\n            * 1e18 / PRECISION / 100;\n    }\n\n    // Acc funding fees (store right before trades opened / closed and fee % update)\n    function storeAccFundingFees(uint pairIndex) private{\n        PairFundingFees storage f = pairFundingFees[pairIndex];\n\n        (f.accPerOiLong, f.accPerOiShort) = getPendingAccFundingFees(pairIndex);\n        f.lastUpdateBlock = block.number;\n\n        emit AccFundingFeesStored(pairIndex, f.accPerOiLong, f.accPerOiShort);\n    }\n    function getPendingAccFundingFees(uint pairIndex) public view returns(\n        int valueLong,\n        int valueShort\n    ){\n        PairFundingFees storage f = pairFundingFees[pairIndex];\n\n        valueLong = f.accPerOiLong;\n        valueShort = f.accPerOiShort;\n\n        int openInterestWETHLong = int(storageT.openInterestWETH(pairIndex, 0));\n        int openInterestWETHShort = int(storageT.openInterestWETH(pairIndex, 1));\n\n        int fundingFeesPaidByLongs = (openInterestWETHLong - openInterestWETHShort)\n            * int(block.number - f.lastUpdateBlock)\n            * int(pairParams[pairIndex].fundingFeePerBlockP)\n            / int(PRECISION) / 100;\n\n        if(openInterestWETHLong > 0){\n            valueLong += fundingFeesPaidByLongs * 1e18\n                / openInterestWETHLong;\n        }\n\n        if(openInterestWETHShort > 0){\n            valueShort += fundingFeesPaidByLongs * 1e18 * (-1)\n                / openInterestWETHShort;\n        }\n    }\n\n    // Dynamic price impact value on trade opening\n    function getTradePriceImpact(\n        uint openPrice,        // PRECISION\n        uint pairIndex,\n        bool long,\n        uint tradeOpenInterest // 1e18 (WETH)\n    ) external view returns(\n        uint priceImpactP,     // PRECISION (%)\n        uint priceAfterImpact  // PRECISION\n    ){\n        (priceImpactP, priceAfterImpact) = getTradePriceImpactPure(\n            openPrice,\n            long,\n            storageT.openInterestWETH(pairIndex, long ? 0 : 1),\n            tradeOpenInterest,\n            long ?\n                pairParams[pairIndex].onePercentDepthAbove :\n                pairParams[pairIndex].onePercentDepthBelow\n        );\n    }\n    function getTradePriceImpactPure(\n        uint openPrice,         // PRECISION\n        bool long,\n        uint startOpenInterest, // 1e18 (WETH)\n        uint tradeOpenInterest, // 1e18 (WETH)\n        uint onePercentDepth\n    ) public pure returns(\n        uint priceImpactP,      // PRECISION (%)\n        uint priceAfterImpact   // PRECISION\n    ){\n        if(onePercentDepth == 0){\n            return (0, openPrice);\n        }\n\n        priceImpactP = (startOpenInterest + tradeOpenInterest / 2)\n            * PRECISION / 1e18 / onePercentDepth;\n        \n        uint priceImpact = priceImpactP * openPrice / PRECISION / 100;\n\n        priceAfterImpact = long ? openPrice + priceImpact : openPrice - priceImpact;\n    }\n\n    // Rollover fee value\n    function getTradeRolloverFee(\n        address trader,\n        uint pairIndex,\n        uint index,\n        uint collateral // 1e18 (WETH)\n    ) public view returns(uint){ // 1e18 (WETH)\n        TradeInitialAccFees memory t = tradeInitialAccFees[trader][pairIndex][index];\n\n        if(!t.openedAfterUpdate){\n            return 0;\n        }\n\n        return getTradeRolloverFeePure(\n            t.rollover,\n            getPendingAccRolloverFees(pairIndex),\n            collateral\n        );\n    }\n    function getTradeRolloverFeePure(\n        uint accRolloverFeesPerCollateral,\n        uint endAccRolloverFeesPerCollateral,\n        uint collateral // 1e18 (WETH)\n    ) public pure returns(uint){ // 1e18 (WETH)\n        return (endAccRolloverFeesPerCollateral - accRolloverFeesPerCollateral)\n            * collateral / 1e18;\n    }\n\n    // Funding fee value\n    function getTradeFundingFee(\n        address trader,\n        uint pairIndex,\n        uint index,\n        bool long,\n        uint collateral, // 1e18 (WETH)\n        uint leverage\n    ) public view returns(\n        int // 1e18 (WETH) | Positive => Fee, Negative => Reward\n    ){\n        TradeInitialAccFees memory t = tradeInitialAccFees[trader][pairIndex][index];\n\n        if(!t.openedAfterUpdate){\n            return 0;\n        }\n\n        (int pendingLong, int pendingShort) = getPendingAccFundingFees(pairIndex);\n\n        return getTradeFundingFeePure(\n            t.funding,\n            long ? pendingLong : pendingShort,\n            collateral,\n            leverage\n        );\n    }\n    function getTradeFundingFeePure(\n        int accFundingFeesPerOi,\n        int endAccFundingFeesPerOi,\n        uint collateral, // 1e18 (WETH)\n        uint leverage\n    ) public pure returns(\n        int // 1e18 (WETH) | Positive => Fee, Negative => Reward\n    ){\n        return (endAccFundingFeesPerOi - accFundingFeesPerOi)\n            * int(collateral) * int(leverage) / 1e18;\n    }\n\n    // Liquidation price value after rollover and funding fees\n    function getTradeLiquidationPrice(\n        address trader,\n        uint pairIndex,\n        uint index,\n        uint openPrice,  // PRECISION\n        bool long,\n        uint collateral, // 1e18 (WETH)\n        uint leverage\n    ) external view returns(uint){ // PRECISION\n        return getTradeLiquidationPricePure(\n            openPrice,\n            long,\n            collateral,\n            leverage,\n            getTradeRolloverFee(trader, pairIndex, index, collateral),\n            getTradeFundingFee(trader, pairIndex, index, long, collateral, leverage)\n        );\n    }\n    function getTradeLiquidationPricePure(\n        uint openPrice,   // PRECISION\n        bool long,\n        uint collateral,  // 1e18 (WETH)\n        uint leverage,\n        uint rolloverFee, // 1e18 (WETH)\n        int fundingFee    // 1e18 (WETH)\n    ) public pure returns(uint){ // PRECISION\n        int liqPriceDistance = int(openPrice) * (\n                int(collateral * LIQ_THRESHOLD_P / 100)\n                - int(rolloverFee) - fundingFee\n            ) / int(collateral) / int(leverage);\n\n        int liqPrice = long ?\n            int(openPrice) - liqPriceDistance :\n            int(openPrice) + liqPriceDistance;\n\n        return liqPrice > 0 ? uint(liqPrice) : 0;\n    }\n\n    // WETH sent to trader after PnL and fees\n    function getTradeValue(\n        address trader,\n        uint pairIndex,\n        uint index,\n        bool long,\n        uint collateral,   // 1e18 (WETH)\n        uint leverage,\n        int percentProfit, // PRECISION (%)\n        uint closingFee    // 1e18 (WETH)\n    ) external onlyCallbacks returns(uint amount){ // 1e18 (WETH)\n        storeAccFundingFees(pairIndex);\n\n        uint r = getTradeRolloverFee(trader, pairIndex, index, collateral);\n        int f = getTradeFundingFee(trader, pairIndex, index, long, collateral, leverage);\n\n        amount = getTradeValuePure(collateral, percentProfit, r, f, closingFee);\n\n        emit FeesCharged(pairIndex, long, collateral, leverage, percentProfit, r, f);\n    }\n    function getTradeValuePure(\n        uint collateral,   // 1e18 (WETH)\n        int percentProfit, // PRECISION (%)\n        uint rolloverFee,  // 1e18 (WETH)\n        int fundingFee,    // 1e18 (WETH)\n        uint closingFee    // 1e18 (WETH)\n    ) public pure returns(uint){ // 1e18 (WETH)\n        int value = int(collateral)\n            + int(collateral) * percentProfit / int(PRECISION) / 100\n            - int(rolloverFee) - fundingFee;\n\n        if(value <= int(collateral) * int(100 - LIQ_THRESHOLD_P) / 100){\n            return 0;\n        }\n\n        value -= int(closingFee);\n\n        return value > 0 ? uint(value) : 0;\n    }\n\n    // Useful getters\n    function getPairInfos(uint[] memory indices) external view returns(\n        PairParams[] memory,\n        PairRolloverFees[] memory,\n        PairFundingFees[] memory\n    ){\n        PairParams[] memory params = new PairParams[](indices.length);\n        PairRolloverFees[] memory rolloverFees = new PairRolloverFees[](indices.length);\n        PairFundingFees[] memory fundingFees = new PairFundingFees[](indices.length);\n\n        for(uint i = 0; i < indices.length; i++){\n            uint index = indices[i];\n\n            params[i] = pairParams[index];\n            rolloverFees[i] = pairRolloverFees[index];\n            fundingFees[i] = pairFundingFees[index];\n        }\n\n        return (params, rolloverFees, fundingFees);\n    }\n    function getOnePercentDepthAbove(uint pairIndex) external view returns(uint){\n        return pairParams[pairIndex].onePercentDepthAbove;\n    }\n    function getOnePercentDepthBelow(uint pairIndex) external view returns(uint){\n        return pairParams[pairIndex].onePercentDepthBelow;\n    }\n    function getRolloverFeePerBlockP(uint pairIndex) external view returns(uint){\n        return pairParams[pairIndex].rolloverFeePerBlockP;\n    }\n    function getFundingFeePerBlockP(uint pairIndex) external view returns(uint){\n        return pairParams[pairIndex].fundingFeePerBlockP;\n    }\n    function getAccRolloverFees(uint pairIndex) external view returns(uint){\n        return pairRolloverFees[pairIndex].accPerCollateral;\n    }\n    function getAccRolloverFeesUpdateBlock(uint pairIndex) external view returns(uint){\n        return pairRolloverFees[pairIndex].lastUpdateBlock;\n    }\n    function getAccFundingFeesLong(uint pairIndex) external view returns(int){\n        return pairFundingFees[pairIndex].accPerOiLong;\n    }\n    function getAccFundingFeesShort(uint pairIndex) external view returns(int){\n        return pairFundingFees[pairIndex].accPerOiShort;\n    }\n    function getAccFundingFeesUpdateBlock(uint pairIndex) external view returns(uint){\n        return pairFundingFees[pairIndex].lastUpdateBlock;\n    }\n    function getTradeInitialAccRolloverFeesPerCollateral(\n        address trader,\n        uint pairIndex,\n        uint index\n    ) external view returns(uint){\n        return tradeInitialAccFees[trader][pairIndex][index].rollover;\n    }\n    function getTradeInitialAccFundingFeesPerOi(\n        address trader,\n        uint pairIndex,\n        uint index\n    ) external view returns(int){\n        return tradeInitialAccFees[trader][pairIndex][index].funding;\n    }\n    function getTradeOpenedAfterUpdate(\n        address trader,\n        uint pairIndex,\n        uint index\n    ) external view returns(bool){\n        return tradeInitialAccFees[trader][pairIndex][index].openedAfterUpdate;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 125
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}